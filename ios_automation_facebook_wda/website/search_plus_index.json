{"./":{"url":"./","title":"前言","keywords":"","body":"iOS自动化测试利器：facebook-wda 最新版本：v1.1 更新时间：20200620 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 简介 总结iOS自动化主流框架facebook-wda的简介，环境搭建以及常见问题，以及开发的心得，尤其是iOS的各种坑，以及常用代码段，并给出部分源码分析，最后附上文档和参考资料。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： Gitbook源码 crifan/ios_automation_facebook_wda: iOS自动化测试利器：facebook-wda 如何使用此Gitbook源码去生成发布为电子书 详见：crifan/gitbook_template: demo how to use crifan gitbook template and demo 在线浏览 iOS自动化测试利器：facebook-wda book.crifan.com iOS自动化测试利器：facebook-wda crifan.github.io 离线下载阅读 iOS自动化测试利器：facebook-wda PDF iOS自动化测试利器：facebook-wda ePub iOS自动化测试利器：facebook-wda Mobi 版权说明 此电子书教程的全部内容，如无特别说明，均为本人原创和整理。其中部分内容参考自网络，均已备注了出处。如有发现侵犯您版权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 23:12:18 "},"intro/":{"url":"intro/","title":"简介","keywords":"","body":"简介 之前已在： 移动端自动化测试概览 中提到过，iOS自动化测试的主流框架之一是：facebook-wda 此处去详细介绍一下。 facebook-wda 主页 openatx/facebook-wda: Facebook WebDriverAgent Python Client Library (not official) 作者：openatx 语言：Python 实现原理 基于Appium的WebDriverAgent 关于WebDriverAgent 简称：WDA 是什么=一句话描述：一个基于W3C的WebDriver的server（的具体实现） 底层依赖：Apple的XCUITest（测试框架） 起源和状态 最早：Facebook开发的 Facebook的WebDriverAgent 现已暂停维护=archived=read-only 主页 facebookarchive/WebDriverAgent: A WebDriver server for iOS that runs inside the Simulator 现在：已停止维护 Appium接手继续维护和更新 Appium的WebDriverAgent 主页 appium/WebDriverAgent: A WebDriver server for iOS that runs inside the Simulator 关于WebDriver 作者：W3C 是什么：一套协议规范 特点：与平台协议无关 目的=作用：远程控制设备 主页 https://w3c.github.io/webdriver/ 关于：Apple的XCUITest 是什么：苹果的测试框架 官网文档 之前： XCUITest （貌似）最新 XCTest | Apple Developer Documentation 关于：Appium Appium: Mobile App Automation crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-01 18:33:14 "},"setup_environment/":{"url":"setup_environment/","title":"搭建环境","keywords":"","body":"搭建环境 此处介绍如何用facebook-wda搭建iOS设备的自动化测试环境。 先介绍facebook-wda的架构流程图： 本地图片 在线网页查看 facebook-wda架构流程图 开发环境概述 开发环境概述 client=客户端 你要测试的iOS设备，比如iPhone 给iPhone中安装WebDriverAgentRunner-Runner server=服务端=test manager=WebDriverAgent的服务 需要在Mac中启动test manager 首次：初始化 先介绍初始化需要做的事情，其中： 初始化 = 第一次 = 首次 = 只需要做一次，以后无需重复做 想要能自动化操作iPhone等iOS设备，需要先去给iPhone中安装： 客户端 = APP = WebDriverAgentRunner-Runner 用于配合Mac中的server端的test manager 安装后的效果： 此处长按变待删除，才能看到app全名是：WebDriverAgentRunner-Runner： 给iPhone中安装WebDriverAgentRunner-Runner 核心思路，都是编译和安装app WebDriverAgentRunner-Runner到iPhone中： 确保Mac中已安装XCode 下载代码： git clone https://github.com/appium/WebDriverAgent.git 切换目录： cd WebDriverAgent 看到相关文件：  ll total 96 -rw-r--r-- 1 limao CORP\\Domain Users 2.0K 2 13 17:40 CONTRIBUTING.md -rw-r--r-- 1 limao CORP\\Domain Users 111B 2 13 17:40 Cartfile -rw-r--r-- 1 limao CORP\\Domain Users 75B 2 13 17:40 Cartfile.resolved drwxr-xr-x 3 limao CORP\\Domain Users 96B 2 13 17:40 Configurations drwxr-xr-x 4 limao CORP\\Domain Users 128B 2 13 17:40 Fastlane -rw-r--r-- 1 limao CORP\\Domain Users 177B 2 13 17:40 Gemfile -rw-r--r-- 1 limao CORP\\Domain Users 4.3K 2 13 17:40 Gemfile.lock -rw-r--r-- 1 limao CORP\\Domain Users 1.5K 2 13 17:40 LICENSE -rw-r--r-- 1 limao CORP\\Domain Users 1.9K 2 13 17:40 PATENTS drwxr-xr-x 7 limao CORP\\Domain Users 224B 2 13 17:40 PrivateHeaders -rw-r--r-- 1 limao CORP\\Domain Users 2.5K 2 13 17:40 README.md drwxr-xr-x 5 limao CORP\\Domain Users 160B 2 13 17:40 Scripts drwxr-xr-x 5 limao CORP\\Domain Users 160B 2 13 17:40 WebDriverAgent.xcodeproj drwxr-xr-x 16 limao CORP\\Domain Users 512B 2 13 17:40 WebDriverAgentLib drwxr-xr-x 4 limao CORP\\Domain Users 128B 2 13 17:40 WebDriverAgentRunner drwxr-xr-x 6 limao CORP\\Domain Users 192B 2 13 17:40 WebDriverAgentTests drwxr-xr-x 5 limao CORP\\Domain Users 160B 2 13 17:40 ci-jobs -rw-r--r-- 1 limao CORP\\Domain Users 666B 2 13 17:40 gulpfile.js -rw-r--r-- 1 limao CORP\\Domain Users 896B 2 13 17:40 index.js drwxr-xr-x 9 limao CORP\\Domain Users 288B 2 13 17:40 lib -rw-r--r-- 1 limao CORP\\Domain Users 2.5K 2 13 17:40 package.json drwxr-xr-x 5 limao CORP\\Domain Users 160B 2 13 17:40 test 其中核心的入口文件，即Xcode项目文件是：WebDriverAgent.xcodeproj 关于如何编译和安装，则有2种方式： 通过IDEXCode去编译和安装 Xcode->Product->Test 在终端运行xcodebuild命令去编译和安装 Terminal中：运行xcodebuild的test 上述操作步骤，和后续的每次运行test manager的方式是一样的，所以细节放在后面介绍。 之后：每次调试之前 启动test manager服务 server=服务端=test manager=WebDriverAgent的服务 需要在Mac中启动test manager 2种方式 XCode Xcode->Product->Test 终端 Terminal中：运行xcodebuild的test 直接一步： xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination \"id=`idevice_id -l | head -n1`\" test 或分2步 先获取iOS设备的UDID： CUR_UDID=$(idevice_id -l | head -n1) 再运行： xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination \"id=$CUR_UDID\" test 注： 要在WebDriverAgent的目录中运行上述命令 idevice_id -l作用是列出当前连接到Mac中的所有iOS的设备（的UDID） 详见：idevice_id head -n1作用是获取第一个（iOS设备的UDID） 最后能看到输出ServerURLHere和Using singleton test manager： 。。。 Test Case '-[UITestingUITests testRunner]' started. t = 0.01s Start Test at 2020-02-20 10:50:59.818 t = 0.01s Set Up 2020-02-20 10:50:59.968359+0800 WebDriverAgentRunner-Runner[460:142725] Built at Feb 20 2020 10:50:08 2020-02-20 10:51:00.119667+0800 WebDriverAgentRunner-Runner[460:142725] ServerURLHere->http://192.168.31.43:8100 即表示正常启动了test manager= WDA的server 了。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-02 15:11:33 "},"setup_environment/note_common_qa.html":{"url":"setup_environment/note_common_qa.html","title":"常见问题和心得","keywords":"","body":"搭建环境期间常见问题和心得 下面整理一些搭建环境期间的常见问题和心得总结： xcodebuild报错：xcode-select error tool xcodebuild requires Xcode 如果运行xcodebuld报错： xcode-select: error: tool 'xcodebuild' requires Xcode, but active developer directory '/Library/Developer/CommandLineTools' is a command line tools instance 原因：没有安装XCode 或 虽然已安装XCode，但是没启用XCode的命令行 解决办法：去安装并开启XCode的命令行 步骤： 文字 Xcode->设置->Locations->Command Line Tools，默认是空，下拉选择Xcode 11.3.1(11C504) 截图 安装后，即可查看版本信息： ~  xcodebuild -version Xcode 11.3.1 Build version 11C504 xcodebuild报错：xcodebuild error missing value for key 如果没有iOS设备（如iPhone）插入到Mac中，则运行： xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination \"id=`idevice_id -l | head -n1`\" test 会报错：  ~/dev/xxx/crawler/appAutoCrawler/AppCrawler/iOSAutomation/refer/WebDriverAgent   master ●  xcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination \"id=`idevice_id -l | head -n1`\" test xcodebuild: error: missing value for key 'id' of option 'Destination' 当前被测iOS设备详情 在启动test manager期间会输出当前被测设备的详细信息 举例： (1) iOS 12.4.5的iPhone6 2020-05-07 09:20:31.198 xcodebuild[2440:2434041] [MT] IDETestOperationsObserverDebug: (B7957682-E70F-46C7-86C2-53AEE7C8993D) Beginning test session WebDriverAgentRunner-B7957682-E70F-46C7-86C2-53AEE7C8993D at 2020-05-07 09:20:31.194 with Xcode 11C504 on target &#x1F4F1; { deviceSerialNumber: DNPND9S1G5MR identifier: ed94089f3e34d5538065a695bfdf03dfbb3c5579 deviceClass: iPhone deviceName: Crifan iPhone6 deviceIdentifier: ed94089f3e34d5538065a695bfdf03dfbb3c5579 productVersion: 12.4.5 buildVersion: 16G161 deviceSoftwareVersion: 12.4.5 (16G161) deviceArchitecture: arm64 deviceTotalCapacity: 60058931200 deviceAvailableCapacity: 38391648256 deviceIsTransient: NO ignored: NO deviceIsBusy: NO deviceIsPaired: YES deviceIsActivated: YES deviceActivationState: Activated isPasscodeLocked: NO deviceType: supportedDeviceFamilies: ( 1 ) applications: (null) provisioningProfiles: (null) hasInternalSupport: NO hasWritableSystem: NO isSupportedOS: YES bootArgs: (null) nextBootArgs: (null) connected: YES isWirelessEnabled: NO connectionType: direct hostname: (null) bonjourServiceName: d4:f4:6f:0a:30:80@fe80::d6f4:6fff:fe0a:3080._apple-mobdev2._tcp.local. activeProxiedDevice: (null) } (12.4.5 (16G161)) USB端口转发 为了测试更方便，最好安装和启动端口转发 具体方式是，用iproxy或mobiledevice实现，把访问Mac本地的端口，转发到USB连接着的iOS设备中 命令： 对于只连接单个iOS设备，比如某个iPhone的话，只需要： iproxy 8100 8100 或： mobiledevice tunnel 8100 8100 更多解释和用法，详见： 端口转发 · 苹果相关开发总结 如何确认test manager服务已正常运行 可以去访问运行了test manager最后所输出的地址： http://192.168.31.43:8100 加上status后是： http://192.168.31.43:8100/status success:: 如果已端口转发则可以把IP换localhost 如果用了端口转发，则可以把IP换成localhost： http://localhost:8100/status 会输出当前状态信息： { \"value\": { \"message\": \"WebDriverAgent is ready to accept commands\", \"state\": \"success\", \"os\": { \"name\": \"iOS\", \"version\": \"12.4.5\", \"sdkVersion\": \"13.0\" }, \"ios\": { \"simulatorVersion\": \"12.4.5\", \"ip\": \"192.168.31.43\" }, \"ready\": true, \"build\": { \"time\": \"Feb 20 2020 10:50:08\", \"productBundleIdentifier\": \"com.facebook.WebDriverAgentRunner\" } }, \"sessionId\": \"38289A64-E467-4458-A0F1-8A3B2A6AAECE\" } crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-18 10:05:52 "},"summary/":{"url":"summary/","title":"开发心得","keywords":"","body":"开发心得 wda如何同时测试多个设备 问：如何用wda同时测试多个设备？ 答：使用不同端口转发 具体做法举例： iproxy 8100 8100 iproxy 8101 8101 iproxy 8102 8102 代码中，本地连接不同端口： gWdaClient = wda.Client('http://localhost:8100’) gWdaClient = wda.Client('http://localhost:8101’) gWdaClient = wda.Client('http://localhost:8102') 即可。 感慨：对于apple的态度 见到别人有提到： Apple公司因其无与伦比的设计，让无数果粉为之迷恋 但作为iOS测试人员，也因为iOS系统封闭和不开放库苦不堪言，羡慕死Android测试 对此深有体会，不能再同意更多： 消费者：对于apple产品觉得很好看，很喜欢 测试、自动化人员：苦不堪言 原因：apple生态封闭，不开放 虽然提供了XCTest，但是很不好用 iOS，Mac等内部的库是不开放的 没法直接用来做测试和自动化 -》Facebook的WebDriverAgent（后由Appium维护）已经做到了 用工具从 私有的库中dump出头文件和api接口 但是实际用起来，仍然是各种bug和不兼容 包括但不限于（后续会介绍到的）各种坑 获取不到源码 只能获取部分源码 获取源码会导致test manager崩溃（需要重装WebDriverAgentRunner） 无法完美支持元素visible属性 获取到的源码很混乱 比如 包含了前一页（甚至几页）的xml源码 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-02 09:53:29 "},"ios_pitfall/":{"url":"ios_pitfall/","title":"iOS的各种坑","keywords":"","body":"iOS的各种坑 在用facebook-wda+WebDriverAgent去自动化测试iOS设备期间，遇到各种坑，现在来详细说说： 坑：即使查询条件和xml中内容正确匹配，也查询不到 对于页面： xml是： 去用： {'value': '可申请(元) 200,000', 'name': '可申请(元) 200,000', 'label': '可申请(元) 200,000', 'enabled': 'true', 'x': '85', 'y': '226', 'width': '244', 'height': '102', 'type': 'XCUIElementTypeStaticText'} 以及 去掉y的： {'value': '可申请(元) 200,000', 'name': '可申请(元) 200,000', 'label': '可申请(元) 200,000', 'enabled': 'true', 'x': '85', 'width': '244', 'height': '102', 'type': 'XCUIElementTypeStaticText'} 都查不到元素。 不过，去掉value，name，label后： {'enabled': 'true', 'x': '85', 'y': '226', 'width': '244', 'height': '102', 'type': 'XCUIElementTypeStaticText'} 是可以查询到元素的，所以很是诡异。 其原因，自己推测是此处的（value等）值有问题 但是具体的值是不是我猜测的 可申请(元) 200000 则无需，也懒得再去试了。 更重要的是，对于： 可申请(元) 200,000 页面上的内容的显示，是肉眼可见的分成了2部分 可申请(元) 200,000 且显示的样式都不同 -> 所以十分怀疑是： iOS内部的元素和代码，其实本身就是这2部分是分开的 只不过是输出xml时，混在了一起 -> 导致通过value（name，label）才找不到元素的 -> 去掉value等值后，只用x、y等坐标值，就能找到：说明是对应着页面上的其中某一个元素 要么是 可申请(元)，或者是200,000 总之是： iOS内部页面内容，和输出xml代码之间，一直做的很垃圾。 或者说故意做的很垃圾，让你很难自动化测试iOS。 详见： 【不去解决】自动抓包iOS的app恒易贷：找不到元素可申请元200000 坑：界面上按钮有文字，但是源码中没有文字 界面上： 本来希望去：写规则去查找button，且name是立即进入 结果源码中 没有我们希望的文字：立即进入 注：目测看起来，这个 立即进入 的button的文字 不是属于button图片本身，而是普通文字，只不过xml源码中，的确找不到 这样就影响了后续代码逻辑的判断，无法准确判断当前页面的按钮，是否是最后一页了。 详见： 【未解决】自动抓包iOS的app：左滑引导页进入首页 不爽的点：页面类似，但xml源码差异很大 对于页面： 但是对应xml： 很明显，页面中的 刷新试试 明显是一个按钮，是没问题的 -> 后续就容易写规则去匹配和处理 但是后来遇到和上面很类似的页面： 可见页面上再刷新下也是一个按钮 但发现xml却是： 再刷新下 却是一个 XCUIElementTypeOther，而不是XCUIElementTypeButton -> 后续代码去处理和写匹配逻辑，就显得很不顺，让人很不爽。 -> 如果也是和前面一样的XCUIElementTypeButton，就容易统一成一个逻辑去处理，更加通用，效率更高。 -> 现在没法统一，效率很低，逻辑上显得很冗余 总体结论： 页面上的元素，和xml源码内容，很多时候，对不上，甚至完全对不上，驴唇不对马嘴的感觉。 详见： 【未解决】自动抓包iOS的app京东金融：网络不稳定刷新试试 【未解决】自动抓包iOS的app京东金融：系统正在开小差再刷新下 坑：有些页面 获取到的源码实际上是空的 没有包含页面元素的源码 比如页面： 希望获取源码中包含弹框部分的内容 但是实际上获取到的是： 即： 中间主体内容是空的 没有包含我们希望看到的 弹框部分 详见： 【未解决】自动抓包iOS的app益路同行：弹框退出游戏 坑：页面中图片明显可见，但是xml源码中visible=false表示不可见 页面中的中间部分的2个图片： 此处xml源码竟然是： 其中 即： 只有一个Image节点，（当前可能本身就是一张图，但是从app中看起来不像，还是像2张图）并且还是visible=false，即不可见！ 你妹的，那还怎么解析出有效节点，根本没法提取有效节点，和后续抓取。 详见： 【未解决】自动抓包工具抓包iOS的app：善友筹 坑：偶尔会遇到 通过坐标值点击元素 无效 实际上误点击别的位置 对于页面： 代码已找到了 取消 按钮，然后去点击 其中间坐标位置 clickCenterPosition(curSession, cancelSoup.attrs) def clickCenterPosition(curSession, elementAttrDict): x = int(elementAttrDict[\"x\"]) y = int(elementAttrDict[\"y\"]) width = int(elementAttrDict[\"width\"]) height = int(elementAttrDict[\"height\"]) centerX = x + int(width / 2) centerY = y + int(height / 2) curSession.click(centerX, centerY) logging.info(\"Clicked [%s, %s]\", centerX, centerY) 之前此点击元素中间位置的代码工作都是正常的 唯独这此，点击 取消按钮 后，实际上是点击了：呼叫 按钮的位置，导致进入 呼叫 界面： 最后无奈，只能绕过这个bug，换用别的方式去点击元素： 用wda的query去查找元素，通过元素点击本身 # parentOtherSoup = callSoup.parent # if parentOtherSoup: # parentParentOtherSoup = parentOtherSoup.parent # if parentParentOtherSoup: # cancelSoup = parentParentOtherSoup.find( # \"XCUIElementTypeButton\", # attrs={\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"取消\"} # ) # if cancelSoup: # clickCenterPosition(curSession, cancelSoup.attrs) # foundAndProcessedPopup = True # above click position not work for 取消 !!! # change to find 取消 then click element cancelButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"visible\":\"true\", \"name\": \"取消\"} foundAndClicked = findAndClickElement(curSession, cancelButtonQuery) foundAndProcessedPopup = foundAndClicked 才可以：点击取消 让弹框消失。 详见： 【已解决】自动抓包iOS的app无忧筹：弹框呼叫拨打电话 【后记1】 又在： 【未解决】自动抓包iOS的app京东金融：弹框想给您发送通知允许 遇到同样的问题： bs4中搜索到了 允许 按钮，去点击 通过点击允许按钮的中间坐标值，结果实际上却是点击了：另外一个按钮 不允许 。。。 然后无奈，只能想办法用wda的query去查询元素 允许，再通过元素点击 估计就可以了。 【后记2】 又在： 【未解决】自动抓包iOS的app恒易贷：弹框使用无线数据无线局域网与蜂窝移动网络 遇到同样问题： 对于页面： 都已经用代码： wifiCellularChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"无线局域网与蜂窝移动网络\"} }, ] wifiCellularSoup = utils.bsChainFind(soup, wifiCellularChainList) if wifiCellularSoup: clickCenterPosition(curSession, wifiCellularSoup.attrs) foundAndProcessedPopup = True return foundAndProcessedPopup 查到并点击了 无线局域网与蜂窝移动网络 按钮的中间位置，但是实际上点击的是：不允许 导致后来app无法访问网络，再次启动app后，也提示请开启网络权限。 只能去改为，wda的元素查找，找到元素后，根据元素去click点击： wifiCellularSoup = CommonUtils.bsChainFind(soup, wifiCellularChainList) if wifiCellularSoup: # self.clickElementCenterPosition(wifiCellularSoup) # foundAndProcessedPopup = True # found 无线局域网与蜂窝移动网络 but actually click center position will click 不允许 ！！！ # change to wda query element then click by element curName = wifiCellularSoup.attrs[\"name\"] # 好 wifiCellularButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curName} foundAndClicked = self.findAndClickElement(wifiCellularButtonQuery, isShowErrLog=False) foundAndProcessedPopup = foundAndClicked return foundAndProcessedPopup 才可以。 【后记3】 由于经常遇到此问题，所以后来专门去提取逻辑到独立函数中，详见常用代码段中的findAndClickButtonElementBySoup 坑：元素查找条件 都写的最完整，不能再详细了，但是却会出现 可以查询到 找到 多个元素 比如页面： 左下角的 3个tab页的父级元素，对应 locator，调试出现警告： [200515 14:23:27][ParsePage.py 1019] Found 2 same node from tag=XCUIElementTypeOther, attr={'name': '筹款首页, tab, 1 of 3 发起筹款, tab, 2 of 3 我的筹款, tab, 3 of 3', 'label': '筹款首页, tab, 1 of 3 发起筹款, tab, 2 of 3 我的筹款, tab, 3 of 3', 'enabled': 'true', 'visible': 'true', 'x': '0', 'y': '687', 'width': '414', 'height': '49', 'type': 'XCUIElementTypeOther'} 提示上述locator可以找到2个元素，然后去xml源码中看看，果然是的： 。。。 就是：底部3个按钮主菜单 的parent 和 parent的parent -》坑就是： 如果通过上述（最详尽的）条件去定位元素，则理论上是会出现多个的 -》无法完美精准定位查询到某个想要的元素。 详见： 【未解决】自动抓包iOS的app：无忧筹点击首页的筹款首页后无法返回 坑：app内部某一层的页面中的xml源码，竟然还保留（之前的几层）父级的元素 比如 某个二级页面： 康爱公社-二级页面-百万医保补充互助社.jpg 其中，正常的符合预期的是，页面xml源码中，有页面中的元素，比如 顶部的第二排的 互助公约 资助公示 本期分摊 联系客服 等 但是点击了 资助公示 后，进入 三级页面： 康爱公社-三级页面-资助公示-弹框提醒.jpg 竟然其中xml源码中，还有 前一页的页面元素： 其中可见，不仅存在之前页面的元素的xml，且竟然是visible=true，即： 表示当前页面可见。但是实际上不可见，不可能看到，前面几级页面的内容。 -》导致后续的基于xml源码判断元素的逻辑，就不可用了。完全混乱了。 即：在第三级页面，也能找到第二级，甚至第一级页面的元素，以为是在第二级或第一级页面呢，无需返回，即可找到并点击相关元素，而实际上页面上，并不是第二级或第一级页面，屏幕上并没有这些元素。 使得后续页面跳转，完全失效。无法继续正常逻辑。 仔细去看xml源码中发现，有个特点： 会存在 pages/xxx/xxx 之类的元素： 。。。 且不止一个： 。。。 其中有几个 page/xxx -> 存在 当前页面 实际上 包含了 几个（前后一共几级的）页面的xml源码 详见： 【无法解决】iOS抓包app康爱公社：第三级页面中也能点击到第一级页面中的元素导致页面无法返回 【规避解决】iOS抓包app康爱公社：第三级别RestPage互助公约子页面无法返回 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-02 10:32:46 "},"common_code/":{"url":"common_code/","title":"常用代码段","keywords":"","body":"常用代码段 在折腾facebook-wda期间，把各种常用的功能，封装成了函数，现整理如下，供需要的参考： findAndClickButtonElementBySoup def findAndClickButtonElementBySoup(self, curButtonSoup=None, curButtonName=None): \"\"\" iOS的bug：根据bs找到了soup元素（往往是一个button）后，用 clickCenterPosition=clickElementCenterPosition 去点击中间坐标，往往会有问题 实际上点击的是别的位置，别的元素 为了规避此bug，所以去： 通过soup，再去找button的wda的元素，然后根据元素去点击 则都是可以正常点击，不会有误点击的问题 \"\"\" # # change to wda element query then click by element # if not curButtonName: # curSoupAttrs = curButtonSoup.attrs # curButtonName = curSoupAttrs[\"name\"] # # rights close white # # login close # curButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curButtonName} # # foundAndClicked = self.findAndClickElement(curButtonQuery) curButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\"} extraQuery = {} # change to wda element query then click by element if curButtonName: extraQuery[\"name\"] = curButtonName else: if curButtonSoup: curSoupAttrs = curButtonSoup.attrs if hasattr(curSoupAttrs, \"name\"): curButtonName = curSoupAttrs[\"name\"] # rights close white # login close extraQuery[\"name\"] = curButtonName else: # no name attribute, use position x = curSoupAttrs[\"x\"] y = curSoupAttrs[\"y\"] width = curSoupAttrs[\"width\"] height = curSoupAttrs[\"height\"] extraQuery[\"x\"] = x extraQuery[\"y\"] = y extraQuery[\"width\"] = width extraQuery[\"height\"] = height # {'enabled': 'true', 'height': '32', 'type': 'XCUIElementTypeButton', 'width': '31', 'x': '339', 'y': '122'} # merge query # curButtonQuery = {**curButtonQuery, **extraQuery} curButtonQuery.update(extraQuery) # {'enabled': 'true', 'height': '32', 'type': 'XCUIElementTypeButton', 'width': '32', 'x': '338', 'y': '150'} foundAndClicked = self.findAndClickElement(curButtonQuery, isShowErrLog=False) return foundAndClicked 不同的地方的各种调用： foundAndProcessedPopup = self.findAndClickButtonElementBySoup(possibleCloseSoup) foundAndProcessedPopup = self.findAndClickButtonElementBySoup(commonCloseSoup) foundAndProcessedPopup = self.findAndClickButtonElementBySoup(wifiCellularSoup) foundAndProcessedPopup = self.findAndClickButtonElementBySoup(okSoup) foundAndProcessedPopup = self.findAndClickButtonElementBySoup(allowSoup) foundAndProcessedPopup = self.findAndClickButtonElementBySoup(curButtonName=\"取消\") 详见： 【已解决】自动抓包iOS的app：优化clickElementCenterPosition点击失效时换用wda寻找元素并点击逻辑 findAndClickCenterPosition 查找并点击元素中间位置 def findAndClickCenterPosition(self, bsChainList, soup=None, isUseWdaQueryAndClick=False): \"\"\"use Beautifulsoup chain list to find soup node then click node center position Args: bsChainList (list): dict list for dict of tag and attrs soup (Soup)): BeautifulSoup soup isUseWdaQueryAndClick (bool): for special node bs click not work, so need change to wda query element then click by element Returns: bool: found and cliked or not Raises: \"\"\" foundAndClicked = False if not soup: curPageXml = self.get_page_source() soup = CommonUtils.xmlToSoup(curPageXml) foundSoup = CommonUtils.bsChainFind(soup, bsChainList) if foundSoup: if isUseWdaQueryAndClick: foundAndClicked = self.findAndClickButtonElementBySoup(foundSoup) else: self.clickElementCenterPosition(foundSoup) foundAndClicked = True return foundAndClicked 场景：米家 弹框 立即体验 xml 调用举例： immediatelyExperienceChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"立即体验\"} }, ] foundAndProcessedPopup = self.findAndClickCenterPosition(immediatelyExperienceChainList, soup) return foundAndProcessedPopup findAndClickButtonElementBySoup 通过soup去用wda的query查找元素并点击 def findAndClickButtonElementBySoup(self, curButtonSoup=None, curButtonName=None): \"\"\" iOS的bug：根据bs找到了soup元素（往往是一个button）后，用 clickCenterPosition=clickElementCenterPosition 去点击中间坐标，往往会有问题 实际上点击的是别的位置，别的元素 为了规避此bug，所以去： 通过soup，再去找button的wda的元素，然后根据元素去点击 则都是可以正常点击，不会有误点击的问题 \"\"\" # # change to wda element query then click by element # if not curButtonName: # curSoupAttrs = curButtonSoup.attrs # curButtonName = curSoupAttrs[\"name\"] # # rights close white # # login close # curButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curButtonName} # # foundAndClicked = self.findAndClickElement(curButtonQuery) curButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\"} extraQuery = {} # change to wda element query then click by element if curButtonName: extraQuery[\"name\"] = curButtonName else: if curButtonSoup: curSoupAttrs = curButtonSoup.attrs if hasattr(curSoupAttrs, \"name\"): curButtonName = curSoupAttrs[\"name\"] # rights close white # login close extraQuery[\"name\"] = curButtonName else: # no name attribute, use position x = curSoupAttrs[\"x\"] y = curSoupAttrs[\"y\"] width = curSoupAttrs[\"width\"] height = curSoupAttrs[\"height\"] extraQuery[\"x\"] = x extraQuery[\"y\"] = y extraQuery[\"width\"] = width extraQuery[\"height\"] = height # {'enabled': 'true', 'height': '32', 'type': 'XCUIElementTypeButton', 'width': '31', 'x': '339', 'y': '122'} # merge query # curButtonQuery = {**curButtonQuery, **extraQuery} curButtonQuery.update(extraQuery) # {'enabled': 'true', 'height': '32', 'type': 'XCUIElementTypeButton', 'width': '32', 'x': '338', 'y': '150'} foundAndClicked = self.findAndClickElement(curButtonQuery, isShowErrLog=False) return foundAndClicked 说明： iOS的bug：根据bs找到了soup元素（往往是一个button）后，用 clickCenterPosition=clickElementCenterPosition 去点击中间坐标，往往会有问题 实际上点击的是别的位置，别的元素 为了规避此bug，所以去： 通过soup，再去找button的wda的元素，然后根据元素去点击 则都是可以正常点击，不会有误点击的问题 调用举例： commonCloseSoup = CommonUtils.bsChainFind(soup, commonCloseChainList) if commonCloseSoup: # self.clickElementCenterPosition(commonCloseSoup) # sometime not work # foundAndProcessedPopup = True # so change to wda query element then click foundAndProcessedPopup = self.findAndClickButtonElementBySoup(commonCloseSoup) isPageHasNaviBar_iOS 是否包含导航栏 def isPageHasNaviBar_iOS(self, page): \"\"\"Check whether current page has XCUIElementTypeNavigationBar\"\"\" hasNaviBar = False naviBarName = \"\" \"\"\" has: 某个公众号：动卡空间 not: \"\"\" soup = CommonUtils.xmlToSoup(page) foundNaviBar = soup.find( 'XCUIElementTypeNavigationBar', attrs={\"type\": \"XCUIElementTypeNavigationBar\", \"enabled\": \"true\"}, ) if foundNaviBar: # maybeFakeNaviBarName = foundNaviBar.attrs[\"name\"] maybeFakeNaviBarName = foundNaviBar.attrs.get(\"name\") typeOtherNameP = re.compile(\"%s,?\" % maybeFakeNaviBarName) foundTypeOther = foundNaviBar.find(\"XCUIElementTypeOther\", attrs={\"type\": \"XCUIElementTypeOther\", \"name\": typeOtherNameP}) if foundTypeOther: hasNaviBar = True naviBarName = maybeFakeNaviBarName return hasNaviBar, naviBarName 调用： OfflinePageNaviBarNameList = [ \"微信\", \"通讯录\", \"公众号\", ] hasNaviBar, naviBarName = self.isPageHasNaviBar_iOS(page) crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 22:49:28 "},"common_code/weixin_related.html":{"url":"common_code/weixin_related.html","title":"微信相关","keywords":"","body":"微信相关 isPublicAccountSearchPage_iOS 判断是否处于微信公众号搜索页 def isPublicAccountSearchPage_iOS(self, page): \"\"\"Check whether current page is Weixin Public account search page\"\"\" isPublicAccountSearch = False curInputValue = \"\" \"\"\" is search: \"\"\" soup = CommonUtils.xmlToSoup(page) widthStr = str(self.X) foundImage = soup.find( 'XCUIElementTypeImage', attrs={\"type\":\"XCUIElementTypeImage\", \"enabled\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":widthStr}, ) if foundImage: foundSearchField = foundImage.find(\"XCUIElementTypeSearchField\", attrs={\"type\": \"XCUIElementTypeSearchField\", \"name\":\"搜索\", \"label\":\"搜索\", \"enabled\":\"true\"} ) if foundSearchField: isPublicAccountSearch = True # curInputValue = foundSearchField.attrs[\"value\"] curInputValue = foundSearchField.attrs.get(\"value\") return isPublicAccountSearch, curInputValue isPublicAccountFocusOrIntoPage_iOS def isPublicAccountFocusOrIntoPage_iOS(self, page): \"\"\"Check whether current page is Weixin Public focus or enter into page\"\"\" isPublicAccountFocusOrInto = False \"\"\" is Focus: is enter into: \"\"\" soup = CommonUtils.xmlToSoup(page) foundNaviBar = soup.find( 'XCUIElementTypeNavigationBar', attrs={\"type\":\"XCUIElementTypeNavigationBar\", \"enabled\":\"true\"}, ) # logging.debug(\"foundNaviBar=%s\", foundNaviBar) if foundNaviBar: foundTypeOther = foundNaviBar.find(\"XCUIElementTypeOther\", attrs={\"type\": \"XCUIElementTypeOther\", \"enabled\":\"true\"} ) logging.debug(\"foundTypeOther=%s\", foundTypeOther) if foundTypeOther: # typeOtherName = foundTypeOther.attrs[\"name\"] typeOtherName = foundTypeOther.attrs.get(\"name\") logging.debug(\"typeOtherName=%s\", typeOtherName) isTypeOtherNameNotEmpty = bool(typeOtherName) isTypeOtherNameEmpty = not isTypeOtherNameNotEmpty logging.debug(\"isTypeOtherNameEmpty=%s\", isTypeOtherNameEmpty) if isTypeOtherNameEmpty: foundIntoAccount = soup.find( 'XCUIElementTypeButton', attrs={\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\":\"进入公众号\", \"label\":\"进入公众号\"}, ) logging.debug(\"foundIntoAccount=%s\", foundIntoAccount) if foundIntoAccount: prevSiblingList = foundIntoAccount.previous_siblings logging.debug(\"prevSiblingList=%s\", prevSiblingList) curAccountZhcnName = self.account_zw TypeStaticText = \"XCUIElementTypeStaticText\" for eachPrevSibling in prevSiblingList: # curType = eachPrevSibling.attrs[\"type\"] # curName = eachPrevSibling.attrs[\"name\"] # curType = eachPrevSibling.attrs.get(\"type\") # curName = eachPrevSibling.attrs.get(\"name\") if hasattr(eachPrevSibling, \"attrs\"): curType = eachPrevSibling.attrs.get(\"type\") curName = eachPrevSibling.attrs.get(\"name\") if (curType == TypeStaticText) and (curName == curAccountZhcnName): isPublicAccountFocusOrInto = True else: logging.debug(\"eachPrevSibling=%s no attrs\", eachPrevSibling) logging.debug(\"isPublicAccountFocusOrInto=%s\", isPublicAccountFocusOrInto) return isPublicAccountFocusOrInto 调用： def isCurPageInOffline_iOS(self, page): \"\"\"Check whether current page is belong to (unexpeced) offiline page offline page include: * 微信首页 * 微信通讯录 * 微信公众号列表页 * 微信公众号搜索-待输入 * 微信公众号搜索-输入公众号ID * 微信公众号搜索-搜索结果 * 微信公众号-关注公众号 * 微信公众号-进入公众号 \"\"\" isOffline = False OfflinePageNaviBarNameList = [ \"微信\", \"通讯录\", \"公众号\", ] hasNaviBar, naviBarName = self.isPageHasNaviBar_iOS(page) if hasNaviBar: if naviBarName in OfflinePageNaviBarNameList: # is in some weixin page isOffline = True if not isOffline: isPublicAccountSearch, curInputValue = self.isPublicAccountSearchPage_iOS(page) if isPublicAccountSearch: # is in public account search page isOffline = True if not isOffline: isPublicAccountFocusOrIntoPage = self.isPublicAccountFocusOrIntoPage_iOS(page) if isPublicAccountFocusOrIntoPage: # is in public account focus or enter into page isOffline = True return isOffline 当发生异常提示时，一直点击（多数都是 下一步），直到退出异常提示 def iOSMakesureIntoWeixin(self): \"\"\"Makesure into weixin main page if exception, process it, until into weixin page \"\"\" # maxRetryNum = 3 maxRetryNum = 5 beInWeixin = self.iOSisInWeixin() while (not beInWeixin) and (maxRetryNum > 0): beInWeixin = self.iOSisInWeixin() if not beInWeixin: # try process for exception foundAndProcessedException = self.iOSWeixinExceptionNextStep() if foundAndProcessedException: beInWeixin = self.iOSisInWeixin() maxRetryNum -= 1 return beInWeixin def iOSWeixinExceptionNextStep(self): foundAndClicked = False scrollViewClassChain = \"/XCUIElementTypeScrollView[`rect.width = %d AND rect.height = %d`]\" % (self.X, self.totalY) ButtonLabelNextStep = \"下一步\" ButtonLabelIntoWeixin = \"进入微信\" # nextStepButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"label\": \"下一步\", \"enabled\": \"true\"} # nextStepButtonQuery[\"parent_class_chains\"] = [scrollViewClassChain] # intoWeixinButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"label\": \"进入微信\", \"enabled\": \"true\"} # intoWeixinButtonQuery[\"parent_class_chains\"] = [scrollViewClassChain] \"\"\" \"\"\" # continousExceptionQuery = {\"type\":\"XCUIElementTypeStaticText\", \"value\": \"当前检测出微信连续异常，你可以尝试以下方法修复：\", \"enabled\": \"true\"} # continousExceptionQuery[\"parent_class_chains\"] = [scrollViewClassChain] # isFoundContinousException, respInfo = self.findElement(query=continousExceptionQuery, timeout=0.5) # if isFoundContinousException: # isFoundNextStep, respInfo = self.findElement(query=nextStepButtonQuery) # if isFoundNextStep: # nextStepElement = respInfo # foundAndClicked = self.clickElement(nextStepElement) \"\"\" \"\"\" # # if not foundAndClicked: # rebootWeixinQuery = {\"type\":\"XCUIElementTypeStaticText\", \"value\": \"建议你重启手机，避免微信启动异常\", \"enabled\": \"true\"} # rebootWeixinQuery[\"parent_class_chains\"] = [scrollViewClassChain] # isFoundRebootWeixin, respInfo = self.findElement(query=rebootWeixinQuery, timeout=0.5) # if isFoundRebootWeixin: # isFoundNextStep, respInfo = self.findElement(query=nextStepButtonQuery) # if isFoundNextStep: # nextStepElement = respInfo # foundAndClicked = self.clickElement(nextStepElement) \"\"\" \"\"\" # # if not foundAndClicked: # clearCacheQuery = {\"type\":\"XCUIElementTypeStaticText\", \"value\": \"清理缓存会清理你的手机本地缓存文件，但不会清理你的消息数据，使用后需要重新登录微信\", \"enabled\": \"true\"} # clearCacheQuery[\"parent_class_chains\"] = [scrollViewClassChain] # isFoundClearCache, respInfo = self.findElement(query=clearCacheQuery, timeout=0.5) # if isFoundClearCache: # isFoundNextStep, respInfo = self.findElement(query=nextStepButtonQuery) # if isFoundNextStep: # nextStepElement = respInfo # foundAndClicked = self.clickElement(nextStepElement) \"\"\" \"\"\" \"\"\" \"\"\" EachStepNoticeList = [ # (\"当前检测出微信连续异常，你可以尝试以下方法修复：\", ButtonLabelNextStep), (\"当前检测出微信连续异常\", ButtonLabelNextStep), (\"建议你重启手机，避免微信启动异常\", ButtonLabelNextStep), (\"清理缓存会清理你的手机本地缓存文件，但不会清理你的消息数据，使用后需要重新登录微信\", ButtonLabelNextStep), (\"如果问题还没解决，你可以上传手机日志文件，协助技术人员解决问题。所上传的文件不会包含聊天记录等私人内容，且不会被对外传播\", ButtonLabelNextStep), (\"如果使用过程中还出现问题，建议你重启手机，更新系统，或者联系我们的客服人员。\", ButtonLabelIntoWeixin), ] for (curStepNotice, buttonLabel) in EachStepNoticeList: # curNoticeQuery = {\"type\":\"XCUIElementTypeStaticText\", \"value\": curStepNotice, \"enabled\": \"true\"} # curNoticeQuery = {\"type\":\"XCUIElementTypeStaticText\", \"value_part\": curStepNotice, \"enabled\": \"true\"} curNoticeQuery = {\"type\":\"XCUIElementTypeStaticText\", \"valueContains\": curStepNotice, \"enabled\": \"true\"} curNoticeQuery[\"parent_class_chains\"] = [scrollViewClassChain] isFoundCurNotice, respInfo = self.findElement(query=curNoticeQuery, timeout=0.5) if isFoundCurNotice: # isFoundNextStep, respInfo = self.findElement(query=nextStepButtonQuery) # isFoundButton, respInfo = self.findElement(query=buttonQuery) buttonQuery = {\"type\":\"XCUIElementTypeButton\", \"label\": buttonLabel, \"enabled\": \"true\"} buttonQuery[\"parent_class_chains\"] = [scrollViewClassChain] isFoundButton, respInfo = self.findElement(query=buttonQuery) if isFoundButton: buttonElement = respInfo clickOk = self.clickElement(buttonElement) if clickOk: foundAndClicked = clickOk return foundAndClicked 说明： 通过wda多次调试iOS微信，会导致退出再打开，时不时的会出现异常提示 希望一直点击，直到提示消失 详见： 【已解决】自动抓包工具适配iOS：当前检测出微信连续异常，你可以尝试一下方法修复 下一步 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 23:10:32 "},"common_code/process_popup.html":{"url":"common_code/process_popup.html","title":"弹框处理","keywords":"","body":"iOS弹框处理 背景：iOS的各种app，有各种类型的弹框，目前主要是通过 wda的query 和 获取源码后bs的find找到过滤，再去点击让弹框消失 其中此处分成了2部分： 首次启动后，可能会遇到的弹框：process_popup_iOS_FirstLaunchBeforeMain 其他正常运行期间，可能会遇到的弹框：process_popup_iOS process_popup_iOS_FirstLaunchBeforeMain def process_popup_iOS_FirstLaunchBeforeMain(self, soup=None): \"\"\" 处理iOS中app，在首次登录，进入主页之前，的弹框 \"\"\" foundAndProcessedPopup = False if not soup: curPageXml = self.get_page_source() soup = CommonUtils.xmlToSoup(curPageXml) # if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessPopupUpperRightClose(soup) # if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessPopupUpperRightAlertClose(soup) # Note: put common upper right close, for some app, eg 必要, before show main page, exist these popup if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessPopupUpperRightCommonClose(soup) foundAndProcessedPopup = self.iOSProcessPopupCommonNameContainClose(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupPossibleCloseButton(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupUnderCloseButton(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupIKnow(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessCommonUserAgreementAgree(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessUserPrivacyProtocol(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessAlertUseWirelessData(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessCommonAlertAllow(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessCommonAlertOk(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessRightUpperJumpOver(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupCommonSave(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupCommonConfirmButton(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupImmediatelyExperience(soup) return foundAndProcessedPopup process_popup_iOS def process_popup_iOS(self, curPageXml): foundAndProcessedPopup = False soup = CommonUtils.xmlToSoup(curPageXml) if not foundAndProcessedPopup: foundAndProcessedPopup = self.process_popup_iOS_FirstLaunchBeforeMain(soup) if self.isSpecialiOSApp_kags: if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessKagsPopupStillNotLogin(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupPhoneCall(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessSettingsAllowUseLocation(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupCertificateError(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupNetworkNotStableRetry(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupNetworkNotStableRefresh(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupSystemAbnormalRetryRefresh(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupServerBusyLaterRetry(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupWeixinLogin(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupJumpThirdApp(soup) if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessPopupGetInfoFail(soup) foundAndProcessedPopup = self.iOSProcessPopupDoSomeFail(soup) if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessPopupMiniprogamAuthority(soup) foundAndProcessedPopup = self.iOSProcessPopupMiniprogamGetYour(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupWeixinAuthorizeLocation(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupMiniprogamWarning(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupMiniprogamDisclaimer(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessWillOpenNonOfficialPage(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessAlertNoteConfrim(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessAlertCancel(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessAlertCommonGiveup(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupPhotoCamera(soup) # 注：此逻辑经常误判，没有弹框误以为有弹框，所以放弃此逻辑 # if not foundAndProcessedPopup: # foundAndProcessedPopup = self.iOSProcessCommonPopupWindowUpperRightClose(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupSovereignHasRead(soup) if not foundAndProcessedPopup: foundAndProcessedPopup = self.iOSProcessPopupCommonWindowCancel(soup) return foundAndProcessedPopup 具体实现： iOSProcessPopupImmediatelyExperience def iOSProcessPopupImmediatelyExperience(self, soup): \"\"\" 弹框 other->other-button name=立即体验 \"\"\" \"\"\" 米家 弹框 立即体验： \"\"\" immediatelyExperienceChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"立即体验\"} }, ] foundAndProcessedPopup = self.findAndClickCenterPosition(immediatelyExperienceChainList, soup) return foundAndProcessedPopup iOSProcessPopupCommonConfirmButton def iOSProcessPopupCommonConfirmButton(self, soup): \"\"\" other下面other下的button name=\"确定\" \"\"\" foundAndProcessedPopup = False \"\"\" 米家 弹框 米家隐私政策 确定： \"\"\" confirmChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"确定\"} }, ] confirmSoup = CommonUtils.bsChainFind(soup, confirmChainList) if confirmSoup: self.clickElementCenterPosition(confirmSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupCommonSave def iOSProcessPopupCommonSave(self, soup): \"\"\" 通用的弹框 other下的other下的button name=保存 \"\"\" foundAndProcessedPopup = False \"\"\" 米家 弹框 地区选择 保存： \"\"\" commonSaveChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"保存\"} }, ] commonSaveSoup = CommonUtils.bsChainFind(soup, commonSaveChainList) if commonSaveSoup: self.clickElementCenterPosition(commonSaveSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupCommonWindowCancel def iOSProcessPopupCommonWindowCancel(self, soup): \"\"\" 通用的弹框 window下的other下的button name=取消 \"\"\" foundAndProcessedPopup = False \"\"\" 斑马AI课 弹框 该音频为专属音频 取消： \"\"\" commonCancelChainList = [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": self.FullScreenAttrDict }, { \"tag\": \"XCUIElementTypeOther\", # \"attrs\": self.FullScreenAttrDict \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"取消\"} }, ] commonCancelSoup = CommonUtils.bsChainFind(soup, commonCancelChainList) if commonCancelSoup: self.clickElementCenterPosition(commonCancelSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupSovereignHasRead def iOSProcessPopupSovereignHasRead(self, soup): \"\"\" 必要 弹框 朕已阅 \"\"\" foundAndProcessedPopup = False \"\"\" 必要 弹框 朕已阅： \"\"\" hasReadChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeImage\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"朕已阅\"} }, ] hasReadCloseSoup = CommonUtils.bsChainFind(soup, hasReadChainList) if hasReadCloseSoup: self.clickElementCenterPosition(hasReadCloseSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessAlertCommonGiveup def iOSProcessAlertCommonGiveup(self, soup): \"\"\" 通用逻辑：对于alert弹框， 找里面的 放弃 button，并点击 \"\"\" foundAndProcessedPopup = False \"\"\" 京东金融 弹框 是否放弃注册？ \"\"\" giveupChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"放弃\"} }, ] alertGiveupSoup = CommonUtils.bsChainFind(soup, giveupChainList) if alertGiveupSoup: self.clickElementCenterPosition(alertGiveupSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupServerBusyLaterRetry def iOSProcessPopupServerBusyLaterRetry(self, soup): foundAndProcessedPopup = False \"\"\" 京东金融 异常页面 服务器繁忙，请稍后重试 \"\"\" busyRetryChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"value\": \"服务器繁忙，请稍后重试\"} }, ] busyRetrySoup = CommonUtils.bsChainFind(soup, busyRetryChainList) if busyRetrySoup: # find back button parentOtherSoup = busyRetrySoup.parent parentParentOtherSoup = parentOtherSoup.parent if parentParentOtherSoup: backupP = re.compile(\"backup\") # \"com icon backup u\" backupSoup = parentParentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": backupP} ) if backupSoup: self.clickElementCenterPosition(backupSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupSystemAbnormalRetryRefresh def iOSProcessPopupSystemAbnormalRetryRefresh(self, soup): foundAndProcessedPopup = False \"\"\" 京东金融 异常页面 系统正在开小差，请稍后再试 再刷新下： \"\"\" retryRefreshChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"再刷新下\"} }, ] retryRefreshSoup = CommonUtils.bsChainFind(soup, retryRefreshChainList) if retryRefreshSoup: self.clickElementCenterPosition(retryRefreshSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupUnderCloseButton def iOSProcessPopupUnderCloseButton(self, soup): \"\"\" 弹框 关闭按钮在弹框下面的 尤其是 name=\"\" \"\"\" foundAndProcessedPopup = False \"\"\" 途虎养车 弹框 关闭按钮在下面 新人618全品类消费券： \"\"\" specialChar = \"\" underCloseChainList = [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": self.FullScreenAttrDict, }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict, }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": specialChar} }, ] underCloseSoup = CommonUtils.bsChainFind(soup, underCloseChainList) if underCloseSoup: self.clickElementCenterPosition(underCloseSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupPossibleCloseButton def isPopupWindowSize(self, curSize): \"\"\"判断一个soup的宽高大小是否是弹框类窗口(Image,Other等）的大小\"\"\" # global FullScreenSize FullScreenSize = self.X * self.totalY curSizeRatio = curSize / FullScreenSize # 0.289 PopupWindowSizeMinRatio = 0.25 # PopupWindowSizeMaxRatio = 0.9 PopupWindowSizeMaxRatio = 0.8 # isSizeValid = curSizeRatio >= MinPopupWindowSizeRatio # is popup like window, size should large enough, but should not full screen isSizeValid = PopupWindowSizeMinRatio other -> button 且 button的 w和h基本一致，后者差距小于w和h最大值的10% 以及 w和h都在一定（普通关闭按钮的大小）范围，比如 20-60 必要 我的 蒙层弹框 首次使用引导页： 基于上面逻辑： window->other->button button条件不变 基础上，底层判断逻辑是： next的sibling后面，有且只有一个button，且有name 且按钮宽高大小在合理范围，比如普通按钮的大小，算作为 30x30 window -> Other button条件不变 其他条件类似于第一个，但是是 prev的sibling 是个Other元素，且面积是弹框类大小 \"\"\" foundAndProcessedPopup = False \"\"\" 必要 弹框 首单限时福利 右上角 关闭按钮： 。。。 必要 我的 蒙层弹框 首次使用引导页： 。。。 必要 弹框 推荐开通以下授权 关闭按钮在弹框下面：： 。。。 \"\"\" # noNameP = re.compile(\"???\") noNameP = False possibleCloseChainList = [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": noNameP} }, ] possibleCloseSoup = CommonUtils.bsChainFind(soup, possibleCloseChainList) isCloseUnderPopup = False if not possibleCloseSoup: # 尝试找 是否是 关闭按钮在弹框下面的 弹框 closeUnderPopupChainList = [ { \"tag\": \"XCUIElementTypeApplication\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": noNameP} }, ] possibleCloseSoup = CommonUtils.bsChainFind(soup, closeUnderPopupChainList) if possibleCloseSoup: isCloseUnderPopup = True if possibleCloseSoup: # check is match close button rule or not isValidSize = False isAlmostSameWH = False # isNexSiblingImage = False # isImageSizeValid = False isPossibleClose = True if isPossibleClose: soupAttrDict = possibleCloseSoup.attrs # {'enabled': 'true', 'height': '32', 'type': 'XCUIElementTypeButton', 'visible': 'true', 'width': '31', 'x': '339', 'y': '122'} logging.debug(\"possibleCloseSoup soupAttrDict=%s\", soupAttrDict) # x = int(soupAttrDict[\"x\"]) # y = int(soupAttrDict[\"y\"]) width = int(soupAttrDict[\"width\"]) height = int(soupAttrDict[\"height\"]) # ButtonMinWH = 20 # ButtonMinWH = 30 ButtonMinWH = 25 ButtonMaxWH = 60 isValidWidth = ButtonMinWH iOSProcessPopupCommonNameContainClose # def iOSProcessPopupUpperRightCommonClose(self, soup): def iOSProcessPopupCommonNameContainClose(self, soup): foundAndProcessedPopup = False \"\"\" 京东金融 登录页 弹框 右上角 关闭按钮： 京东金融 tab2财富 弹框 我是Max alertClose： 。。。 必要 弹框 右上角关闭按钮 name中有close： 必要 验证码登录页 左上角 关闭 按钮 name中含close： \"\"\" commonCloseP = re.compile(\"close\", flags=re.I) # com icon black close u # jr fianncing alertClose@3x # rights close white # login close commonCloseChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X} \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": commonCloseP} }, ] commonCloseSoup = CommonUtils.bsChainFind(soup, commonCloseChainList) if commonCloseSoup: # self.clickElementCenterPosition(commonCloseSoup) # sometime not work # foundAndProcessedPopup = True # so change to wda query element then click foundAndProcessedPopup = self.findAndClickButtonElementBySoup(commonCloseSoup) return foundAndProcessedPopup iOSProcessPopupUpperRightAlertClose # def iOSProcessPopupUpperRightAlertClose(self, soup): # foundAndProcessedPopup = False # \"\"\" # 京东金融 tab2财富 弹框 我是Max alertClose： # # 。。。 # # # \"\"\" # alertCloseP = re.compile(\"alertClose\") # alertCloseChainList = [ # { # \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} # }, # { # \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} # }, # { # \"tag\": \"XCUIElementTypeButton\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": alertCloseP} # }, # ] # alertCloseSoup = CommonUtils.bsChainFind(soup, alertCloseChainList) # if alertCloseSoup: # self.clickElementCenterPosition(alertCloseSoup) # foundAndProcessedPopup = True # return foundAndProcessedPopup # def iOSProcessPopupUpperRightClose(self, soup): # foundAndProcessedPopup = False # \"\"\" # 京东金融 登录页 弹框 右上角 关闭按钮： # # # # # # \"\"\" # containCloseP = re.compile(\"close\") # com icon black close u # closeChainList = [ # { # \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} # }, # { # \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X} # }, # { # \"tag\": \"XCUIElementTypeButton\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": containCloseP} # }, # ] # closeSoup = CommonUtils.bsChainFind(soup, closeChainList) # if closeSoup: # self.clickElementCenterPosition(closeSoup) # foundAndProcessedPopup = True # return foundAndProcessedPopup iOSProcessRightUpperJumpOver def iOSProcessRightUpperJumpOver(self, soup): foundAndProcessedPopup = False \"\"\" 京东金融 登录页 右上角 跳过： \"\"\" jumpOverChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"跳过\"} }, ] jumpOverSoup = CommonUtils.bsChainFind(soup, jumpOverChainList) if jumpOverSoup: self.clickElementCenterPosition(jumpOverSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessAlertUseWirelessData def iOSProcessAlertUseWirelessData(self, soup): foundAndProcessedPopup = False \"\"\" 恒易贷 允许使用无线数据 无线局域网与蜂窝移动网络： \"\"\" wifiCellularChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"无线局域网与蜂窝移动网络\"} }, ] wifiCellularSoup = CommonUtils.bsChainFind(soup, wifiCellularChainList) if wifiCellularSoup: # found 无线局域网与蜂窝移动网络 but # self.clickElementCenterPosition(wifiCellularSoup) # actually clicked 不允许 ！！！ # foundAndProcessedPopup = True # # change to wda query element then click by element # curName = wifiCellularSoup.attrs[\"name\"] # 好 # wifiCellularButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curName} # foundAndClicked = self.findAndClickElement(wifiCellularButtonQuery, isShowErrLog=False) # foundAndProcessedPopup = foundAndClicked foundAndProcessedPopup = self.findAndClickButtonElementBySoup(wifiCellularSoup) return foundAndProcessedPopup iOSProcessCommonAlertOk def iOSProcessCommonAlertOk(self, soup): \"\"\" 对于 alert弹框，点击 好 \"\"\" foundAndProcessedPopup = False \"\"\" 恒易贷 弹框 想访问您的通讯录 好： \"\"\" accessYourP = re.compile(\"想访问您的\") # “恒易贷”想访问您的通讯录 okChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": accessYourP} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"好\"} }, ] okSoup = CommonUtils.bsChainFind(soup, okChainList) if okSoup: # clickCenterPosition(curSession, okSoup.attrs) # foundAndProcessedPopup = True # # Note: seems actual click is No allow button? -> not work ! # # change to wda query element then click for makesure work # curName = okSoup.attrs[\"name\"] # 好 # okButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curName} # foundAndClicked = self.findAndClickElement(okButtonQuery, isShowErrLog=False) # foundAndProcessedPopup = foundAndClicked foundAndProcessedPopup = self.findAndClickButtonElementBySoup(okSoup) return foundAndProcessedPopup iOSProcessCommonAlertAllow def iOSProcessCommonAlertAllow(self, soup): foundAndProcessedPopup = False \"\"\" 京东金融 弹框 想给您发送信息 允许： 京东金融 弹框 允许“京东金融”在您使用该应用时访问您的位置吗？ 允许： 京东金融 弹框 允许在您并未使用该应用时访问您的位置吗？仅在使用应用期间 始终允许： 恒易贷 想给您发送通知 允许： \"\"\" # allowP = re.compile(\"(始终)?允许\") # will also match \"不允许\" allowP = re.compile(\"^(始终)?允许$\") # only match \"允许\" \"始终允许\" allowChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"允许\"} \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": allowP} }, ] allowSoup = CommonUtils.bsChainFind(soup, allowChainList) if allowSoup: # clickCenterPosition(curSession, allowSoup.attrs) # foundAndProcessedPopup = True # # above click position not work for 允许 -> actually click 不允许 !!! # # change to use wda to find 允许 then click element # curName = allowSoup.attrs[\"name\"] # 允许 / 始终允许 # # allowButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": \"允许\"} # allowButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": curName} # foundAndClickeAllow = self.findAndClickElement(allowButtonQuery, isShowErrLog=False) # foundAndProcessedPopup = foundAndClickeAllow foundAndProcessedPopup = self.findAndClickButtonElementBySoup(allowSoup) return foundAndProcessedPopup iOSProcessUserPrivacyProtocol def iOSProcessUserPrivacyProtocol(self, soup): foundAndProcessedPopup = False \"\"\" 恒易贷 首次进入 用户隐私保护协议 点击 我接受 \"\"\" \"\"\" 恒易贷 用户意思保护协议 我接收： \"\"\" userPrivacyIAcceptChainList = [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"我接受\"} }, ] userPrivacyIAcceptSoup = CommonUtils.bsChainFind(soup, userPrivacyIAcceptChainList) if userPrivacyIAcceptSoup: self.clickElementCenterPosition(userPrivacyIAcceptSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessCommonUserAgreementAgree def iOSProcessCommonUserAgreementAgree(self, soup): \"\"\" 京东金融、必要 首次进入 授权协议提示 点击 同意 \"\"\" foundAndProcessedAgreement = False \"\"\" 京东金融 首次进入 协议提示 同意： 。。。 必要 用户服务协议及必要隐私政策 同意： 斑马AI课 弹框 个人信息保护政策 同意： \"\"\" commonAgreeChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"同意\"} }, ] commonAgreeSoup = CommonUtils.bsChainFind(soup, commonAgreeChainList) if commonAgreeSoup: self.clickElementCenterPosition(commonAgreeSoup) foundAndProcessedAgreement = True return foundAndProcessedAgreement iOSProcessPopupIKnow def iOSProcessPopupIKnow(self, soup): \"\"\" 京东金融 首次打开 协议弹框 我知道了 \"\"\" foundAndProcessedPopup = False \"\"\" 京东金融 弹框 我知道了： 恒易贷 权限获取说明 我知道了： \"\"\" iKnowChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"我知道了\"} }, ] iKnowSoup = CommonUtils.bsChainFind(soup, iKnowChainList) if iKnowSoup: self.clickElementCenterPosition(iKnowSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupPhoneCall def iOSProcessPopupPhoneCall(self, soup): \"\"\"iOS 通用弹框 呼叫 -> 点击 取消\"\"\" foundAndProcessedPopup = False \"\"\" iOS 通用弹框 呼叫 打电话： \"\"\" callChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"呼叫\"} }, ] callSoup = CommonUtils.bsChainFind(soup, callChainList) if callSoup: # parentOtherSoup = callSoup.parent # if parentOtherSoup: # parentParentOtherSoup = parentOtherSoup.parent # if parentParentOtherSoup: # cancelSoup = parentParentOtherSoup.find( # \"XCUIElementTypeButton\", # attrs={\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"取消\"} # ) # if cancelSoup: # clickCenterPosition(curSession, cancelSoup.attrs) # foundAndProcessedPopup = True # # above click position not work for 取消 !!! # # change to find 取消 then click element # cancelButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"visible\":\"true\", \"name\": \"取消\"} # foundAndClickeCancel = self.findAndClickElement(cancelButtonQuery, isShowErrLog=False) # foundAndProcessedPopup = foundAndClickeCancel foundAndProcessedPopup = self.findAndClickButtonElementBySoup(curButtonName=\"取消\") return foundAndProcessedPopup iOSProcessCommonPopupWindowUpperRightClose # 注：此逻辑经常误判，没有弹框误以为有弹框，所以放弃此逻辑 def iOSProcessCommonPopupWindowUpperRightClose(self, soup): \"\"\"iOS 常见 通用弹框： 中间有多层 XCUIElementTypeOther 且 是全屏大小 enabled=\"true\" visible=\"true\" x=\"0\" y=\"0\" width=\"414\" height=\"736\" 至少3层，其下 再去找 就是 弹框本身最外层元素了 然后尝试点击右上角关闭按钮 \"\"\" foundAndProcessedPopup = False \"\"\" 弹框中找 外层Other内部的 非x=0 y=0的元素，则为弹框区域 计算出其右上角的区域，点击 尝试关闭 弹框 。。。 \"\"\" allTopOtherSoupList = soup.find_all( \"XCUIElementTypeOther\", attrs={\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} ) for eachTopOtherSoup in allTopOtherSoupList: popupTopOtherSoup = self.findPopupTopFrameElement(eachTopOtherSoup) if popupTopOtherSoup: curAttrsDict = popupTopOtherSoup.attrs curX = int(curAttrsDict[\"x\"]) curY = int(curAttrsDict[\"y\"]) curWidth = int(curAttrsDict[\"width\"]) curHeight = int(curAttrsDict[\"height\"]) curX1 = curX + curWidth curY1 = curY + curHeight PossibleCloseButtonWidth = 40 PossibleCloseButtonHeight = 40 possibleCloseButtonX0 = curX1 - PossibleCloseButtonWidth # possibleCloseButtonY0 = curY + PossibleCloseButtonHeight possibleCloseButtonY0 = curY possibleCloseButtonX1 = curX1 possibleCloseButtonY1 = curY + PossibleCloseButtonHeight # possibleCloseButtonCenterX = possibleCloseButtonX0 + int(PossibleCloseButtonWidth / 2) # possibleCloseButtonCenterY = possibleCloseButtonY0 + int(PossibleCloseButtonHeight / 2) possibleCloseButtonCenterX = int( (possibleCloseButtonX0 + possibleCloseButtonX1) / 2) possibleCloseButtonCenterY = int( (possibleCloseButtonY0 + possibleCloseButtonY1) / 2) possibleCloseButtonCenterPositon = (possibleCloseButtonCenterX, possibleCloseButtonCenterY) self.tap(possibleCloseButtonCenterPositon) foundAndProcessedPopup = True break return foundAndProcessedPopup findPopupTopFrameElement def findPopupTopFrameElement(self, topOtherSoup): \"\"\" 寻找符合条件的子节点，即当前节点向下找，符合一直是 type=\"XCUIElementTypeOther\" enabled=\"true\" visible=\"true\" x=\"0\" y=\"0\" width=\"414\" height=\"736\" 且层数 >= 3，然后再找其下一个 非x=0 y=0的节点 很可能就是 弹框的主体元素 \"\"\" popupTopFrameElement = None # MaxFullScreenSizeLevel = 3 # FullScreenSizeMinLevel = 3 # FullScreenSizeMaxLevel = 6 # see many invalid case is level >= 10, so here restrict to 6, not too much level FullScreenSizLevel = 3 # special: 无忧筹 点击 专属老师 后的弹框 FullScreenAttr = {\"type\": \"XCUIElementTypeOther\", \"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\", \"width\":\"%s\" % self.X, \"height\":\"%s\" % self.totalY} curFullScreenOtherLevel = 0 curSoup = topOtherSoup while True: subOtherSoupList = curSoup.find_all( \"XCUIElementTypeOther\", attrs=FullScreenAttr, recursive=False, ) if not subOtherSoupList: break # only have one child childOtherSoupNum = len(subOtherSoupList) if childOtherSoupNum != 1: break firstOnlyOtherSoup = subOtherSoupList[0] if not firstOnlyOtherSoup: break if not hasattr(firstOnlyOtherSoup, \"attrs\"): break curAttrDict = firstOnlyOtherSoup.attrs allAttrSame = True for eachToCompareKey in FullScreenAttr.keys(): eachToCompareValue = FullScreenAttr[eachToCompareKey] curValue = curAttrDict.get(eachToCompareKey) if curValue != eachToCompareValue: allAttrSame = False break if not allAttrSame: break curSoup = firstOnlyOtherSoup curFullScreenOtherLevel += 1 # if curFullScreenOtherLevel >= MaxFullScreenSizeLevel: # isPossiblePopup = FullScreenSizeMinLevel iOSProcessPopupPhotoCamera def iOSProcessPopupPhotoCamera(self, soup): \"\"\"iOS 系统弹框： 拍照或录像 照片图库 浏览 取消\"\"\" foundAndProcessedPopup = False \"\"\" 系统弹框 拍照或录像： \"\"\" photoCameraChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeTable\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"value\":\"拍照或录像\"} }, ] photoCameraSoup = CommonUtils.bsChainFind(soup, photoCameraChainList) if photoCameraSoup: topParentOtherSoup = None # find top most parent parentLevelNum = 11 curParentSoup = photoCameraSoup for curLevelIdx in range(parentLevelNum): curParentSoup = curParentSoup.parent if not curParentSoup: break if curParentSoup: topParentOtherSoup = curParentSoup if topParentOtherSoup: nextSiblingList = topParentOtherSoup.next_siblings if nextSiblingList: nextOtherSoup = None for eachNextSibling in nextSiblingList: if hasattr(eachNextSibling, \"attrs\"): curType = eachNextSibling.attrs[\"type\"] if curType == \"XCUIElementTypeOther\": # next sibling's first XCUIElementTypeOther nextOtherSoup = eachNextSibling break if nextOtherSoup: cancelSoup = nextOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"取消\"} ) if cancelSoup: self.clickElementCenterPosition(cancelSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessAlertNoteConfrim def iOSProcessAlertNoteConfrim(self, soup): \"\"\"只要符合XCUIElementTypeAlert 且其中有 确定 按钮，则点击\"\"\" foundAndProcessedPopup = False \"\"\" 康爱公社 弹框 提醒 您的身份信息不完整 确定： 康爱公社 弹框 提示 请登录后再进行操作： \"\"\" noteTipP = re.compile(\"((提醒)|(提示))\") alertConfirmChainList = [ { \"tag\": \"XCUIElementTypeAlert\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": noteTipP} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"确定\"} }, ] alertConfirmSoup = CommonUtils.bsChainFind(soup, alertConfirmChainList) if alertConfirmSoup: self.clickElementCenterPosition(alertConfirmSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessAlertCancel def iOSProcessAlertCancel(self, soup): \"\"\"对于常见的XCUIElementTypeAlert，内有 取消，则点击取消\"\"\" foundAndProcessedPopup = False \"\"\" 益路通行 弹框 您是否要退出登录： \"\"\" alertCancelChainList = [ { \"tag\": \"XCUIElementTypeAlert\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\":\"取消\"} }, ] alertCancelSoup = CommonUtils.bsChainFind(soup, alertCancelChainList) if alertCancelSoup: self.clickElementCenterPosition(alertCancelSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessKagsPopupStillNotLogin def iOSProcessKagsPopupStillNotLogin(self, soup): foundAndProcessedPopup = False \"\"\" 康爱公社 弹框 您还未登录： 。。。 \"\"\" stillNotLoginChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"x\":\"0\", \"width\": \"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"您还未登录\"} }, ] stillNotLoginSoup = CommonUtils.bsChainFind(soup, stillNotLoginChainList) if stillNotLoginSoup: parentOtherSoup = stillNotLoginSoup.parent parentParentOtherSoup = parentOtherSoup.parent if parentParentOtherSoup: tempNotLoginSoup = parentParentOtherSoup.find( \"XCUIElementTypeStaticText\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"value\": \"暂不登录\"} ) if tempNotLoginSoup: self.clickElementCenterPosition(tempNotLoginSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessWillOpenNonOfficialPage def iOSProcessWillOpenNonOfficialPage(self, soup): foundAndProcessed = False \"\"\" 将要访问 非有赞官方网页，请确认是否继续访问 \"\"\" willOpenChainList = [ { \"tag\": \"XCUIElementTypeWebView\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"x\":\"0\", \"width\": \"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"x\":\"0\", \"width\": \"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"将要访问\"} }, ] willOpenSoup = CommonUtils.bsChainFind(soup, willOpenChainList) if willOpenSoup: parentOtherSoup = willOpenSoup.parent parentParentOtherSoup = parentOtherSoup.parent if parentParentOtherSoup: continueOpenSoup = parentParentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"继续访问\"} ) if continueOpenSoup: self.clickElementCenterPosition(continueOpenSoup) foundAndProcessed = True return foundAndProcessed iOSProcessSettingsAllowUseLocation def iOSProcessSettingsAllowUseLocation(self, soup): \"\"\"处理 设置中的 使用我的地理位置，并返回前一页 注：往往是出现 弹框-是否授权当前位置，点击 允许后，跳转到此处设置页面 \"\"\" \"\"\" 设置 使用我的地理位置： \"\"\" foundAndProcessedPopup = False useLocationSwitchQuery = {\"type\": \"XCUIElementTypeSwitch\", \"name\": \"使用我的地理位置\", \"enabled\":\"true\"} parentCellClassChain = \"/XCUIElementTypeCell[`enabled = 1 AND rect.width = %d`]\" % self.X useLocationSwitchQuery[\"parent_class_chains\"] = [ parentCellClassChain ] foundAndClickeUseLocation = self.findAndClickElement(useLocationSwitchQuery, isShowErrLog=False) logging.debug(\"foundAndClickeUseLocation=%s\", foundAndClickeUseLocation) if foundAndClickeUseLocation: parentNaviBarClassChain = '/XCUIElementTypeNavigationBar[`enabled = 1 AND name=\"设置\"`]' backButtonQuery = {\"type\": \"XCUIElementTypeButton\", \"name\": \"返回\", \"enabled\":\"true\"} backButtonQuery[\"parent_class_chains\"] = parentNaviBarClassChain foundAndClickeBack = self.findAndClickElement(backButtonQuery, isShowErrLog=False) logging.debug(\"foundAndClickeBack=%s\", foundAndClickeBack) foundAndProcessedPopup = foundAndClickeBack return foundAndProcessedPopup iOSProcessPopupNetworkNotStableRetry def iOSProcessPopupNetworkNotStableRetry(self, soup): \"\"\"Process iOS popup 京东金融 网络不稳定,请点击重试\"\"\" foundAndProcessed = False \"\"\" 京东金融 页面 网络不稳定 请点击重试： \"\"\" networkNotStableChainList = [ { \"tag\": \"XCUIElementTypeTable\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeCell\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"value\": \"网络不稳定,请点击重试\"} }, ] networkNotStableSoup = CommonUtils.bsChainFind(soup, networkNotStableChainList) if networkNotStableSoup: self.clickElementCenterPosition(networkNotStableSoup) foundAndProcessed = True return foundAndProcessed iOSProcessPopupNetworkNotStableRefresh def iOSProcessPopupNetworkNotStableRefresh(self, soup): \"\"\"Process iOS popup 京东金融 页面 网络不稳定 刷新试试\"\"\" foundAndProcessedPopup = False \"\"\" 京东金融 页面 网络不稳定 刷新试试： \"\"\" tryRefreshChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"刷新试试\"} }, ] tryRefreshSoup = CommonUtils.bsChainFind(soup, tryRefreshChainList) if tryRefreshSoup: self.clickElementCenterPosition(tryRefreshSoup) foundAndProcessedPopup = True # # Special: above click by position not work # # so change to wda query element then click # tryRefreshButtonQuery = {\"type\":\"XCUIElementTypeButton\", \"enabled\":\"true\", \"name\": \"刷新试试\"} # foundAndClicked = findAndClickElement(curSession, tryRefreshButtonQuery) # foundAndProcessedPopup = foundAndClicked return foundAndProcessedPopup iOSProcessPopupCertificateError def iOSProcessPopupCertificateError(self, soup): \"\"\"Process iOS popup 安全证书存在问题 网络出错，轻触屏幕重新加载\"\"\" foundAndProcessed = False \"\"\" \"\"\" netErrTouchReloadP = re.compile(\"网络出错，轻触屏幕重新加载\") foundTouchReload = soup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"name\": netErrTouchReloadP, \"enabled\":\"true\"} ) if foundTouchReload: self.clickElementCenterPosition(foundTouchReload) foundAndProcessed = True if not foundAndProcessed: \"\"\" \"\"\" securityWarningChainList = self.generateCommonPopupItemChainList(thirdLevelValue=\"安全警告\") securityWarningSoup = CommonUtils.bsChainFind(soup, securityWarningChainList) if securityWarningSoup: parentButtonSoup = securityWarningSoup.parent if parentButtonSoup: certificateProblemP = re.compile(\"该网站的安全证书存在问题\") foundCertProblem = parentButtonSoup.find( \"XCUIElementTypeStaticText\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"value\":certificateProblemP} ) if foundCertProblem: foundCancel = parentButtonSoup.find( \"XCUIElementTypeStaticText\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"取消\"} ) if foundCancel: self.clickElementCenterPosition(foundCancel) foundAndProcessed = True return foundAndProcessed iOSProcessPopupWeixinLogin def iOSProcessPopupWeixinLogin(self, soup): \"\"\"Process iOS popup 微信登录\"\"\" foundAndProcessedPopup = False \"\"\" \"\"\" weixinLoginChainList = self.generateCommonPopupItemChainList( secondLevelTag=\"XCUIElementTypeOther\", thirdLevelValue=\"微信登录\" ) foundWeixinLogin = CommonUtils.bsChainFind(soup, weixinLoginChainList) tableChainList = self.generateCommonPopupItemChainList( secondLevelTag=\"XCUIElementTypeOther\", thirdLevelTag=\"XCUIElementTypeTable\", ) foundTable = CommonUtils.bsChainFind(soup, tableChainList) if foundWeixinLogin and foundTable: parentOtherSoup = foundWeixinLogin.parent if parentOtherSoup: foundAllowButton = parentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"label\":\"允许\"} ) if foundAllowButton: self.clickElementCenterPosition(foundAllowButton) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupJumpThirdApp def iOSProcessPopupJumpThirdApp(self, soup): \"\"\"Process iOS popup 可能离开微信，打开第三方应用\"\"\" foundAndProcessedPopup = False \"\"\" \"\"\" leaveWeixinChainList = self.generateCommonPopupItemChainList(thirdLevelValue=\"可能离开微信，打开第三方应用\") foundLeaveWeixin = CommonUtils.bsChainFind(soup, leaveWeixinChainList) if foundLeaveWeixin: parentButtonSoup = foundLeaveWeixin.parent if parentButtonSoup: foundCancel = parentButtonSoup.find( \"XCUIElementTypeStaticText\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"取消\"} ) if foundCancel: self.clickElementCenterPosition(foundCancel) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupDoSomeFail # def iOSProcessPopupGetInfoFail(self, soup): def iOSProcessPopupDoSomeFail(self, soup): \"\"\"Process iOS popup 获取信息失败 微信登录失败 等\"\"\" foundAndProcessedPopup = False \"\"\" 微信： 获取信息失败： 。。。 。。。 微信登录失败： 小程序： 获取信息失败： \"\"\" # getInfoFailChainList = self.generateCommonPopupItemChainList(thirdLevelValue=\"获取信息失败\") # getInfoFailSoup = CommonUtils.bsChainFind(soup, getInfoFailChainList) # if getInfoFailSoup: # parentButtonOrOtherSoup = getInfoFailSoup.parent doSomeFailP = re.compile(\"\\S+失败$\") # 获取信息失败, 微信登录失败 doSomeFailChainList = self.generateCommonPopupItemChainList(thirdLevelValue=doSomeFailP) doSomeFailSoup = CommonUtils.bsChainFind(soup, doSomeFailChainList) if doSomeFailSoup: parentButtonOrOtherSoup = doSomeFailSoup.parent if parentButtonOrOtherSoup: # 微信 弹框：获取信息失败 foundConfirm = parentButtonOrOtherSoup.find( \"XCUIElementTypeStaticText\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"value\": \"确定\"} ) if not foundConfirm: # 小程序 弹框：获取信息失败 # 微信 弹框：微信登录失败 foundConfirm = parentButtonOrOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"确定\"} ) if foundConfirm: self.clickElementCenterPosition(foundConfirm) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupWeixinAuthorizeLocation def iOSProcessPopupWeixinAuthorizeLocation(self, soup): \"\"\"Process iOS popup 是否授权当前位置\"\"\" foundAndProcessedPopup = False \"\"\" 微信 弹框 是否授权当前位置： \"\"\" authorizeLocationChainList = [ { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % self.X, \"height\": \"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"是否授权当前位置\"} }, ] authorizeLocationSoup = CommonUtils.bsChainFind(soup, authorizeLocationChainList) if authorizeLocationSoup: parentOtherSoup = authorizeLocationSoup.parent confirmSoup = parentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"确定\"} ) if confirmSoup: self.clickElementCenterPosition(confirmSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupMiniprogamWarning def iOSProcessPopupMiniprogamWarning(self, soup): \"\"\" 微信-小程序 弹框 警告 尚未进行授权，请点击确定跳转到授权页面进行授权 \"\"\" foundAndProcessedPopup = False \"\"\" 微信-小程序 弹框 警告 尚未进行授权： \"\"\" warningChainList = [ { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % self.X, \"height\": \"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"警告\"} }, ] warningSoup = CommonUtils.bsChainFind(soup, warningChainList) if warningSoup: parentOtherSoup = warningSoup.parent confirmSoup = parentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"确定\"} ) if confirmSoup: self.clickElementCenterPosition(confirmSoup) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupMiniprogamGetYour # def iOSProcessPopupMiniprogamAuthority(self, soup): def iOSProcessPopupMiniprogamGetYour(self, soup): \"\"\"Process iOS popup 获取你的昵称、头像、地区及性别 / 获取你的通讯地址 / 需要获取你的地理位置\"\"\" foundAndProcessedPopup = False \"\"\" 弹框 获取你的昵称、头像、地区及性别： 弹框 获取你的通讯地址： 小程序 弹框 需要获取你的地理位置： \"\"\" # getYourP = re.compile(\"获取你的\\S+\") # 获取你的通讯地址， 获取你的昵称、头像、地区及性别 getYourP = re.compile(\"(需要)?获取你的\\S+\") # 获取你的通讯地址， 获取你的昵称、头像、地区及性别，需要获取你的地理位置 getYourChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"x\":\"0\", \"width\": self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"x\":\"0\", \"width\": self.X} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\": getYourP} }, ] getYourSoup = CommonUtils.bsChainFind(soup, getYourChainList) if getYourSoup: parentOther = getYourSoup.parent parentParentOther = None parentParentParentOther = None allowTag = \"XCUIElementTypeButton\" allowAttrs = {\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"允许\"} # 获取你的通讯地址, 获取你的昵称、头像、地区及性别 foundAllow = parentOther.find(allowTag, attrs=allowAttrs) if not foundAllow: # for support future possible case parentParentOther = parentOther.parent foundAllow = parentParentOther.find(allowTag, attrs=allowAttrs) if not foundAllow: # \"贝德玛会员中心\" 需要获取你的地理位置 parentParentParentOther = parentParentOther.parent foundAllow = parentParentParentOther.find(allowTag, attrs=allowAttrs) if foundAllow: self.clickElementCenterPosition(foundAllow) foundAndProcessedPopup = True return foundAndProcessedPopup iOSProcessPopupMiniprogamDisclaimer def iOSProcessPopupMiniprogamDisclaimer(self, soup): \"\"\"Process iOS popup 免责声明\"\"\" foundAndProcessedPopup = False \"\"\" \"\"\" disclaimerChainList = [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": self.X, \"height\": self.totalY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": self.X, \"height\": self.totalY} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\": \"免责声明\"} }, ] disclaimerSoup = CommonUtils.bsChainFind(soup, disclaimerChainList) if disclaimerSoup: parentOtherSoup = disclaimerSoup.parent if parentOtherSoup: foundIKnow = parentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\":\"知道了\"} ) if foundIKnow: self.clickElementCenterPosition(foundIKnow) foundAndProcessedPopup = True return foundAndProcessedPopup 期间部分相关函数： def generateCommonPopupItemChainList(self, firstLevelTag=\"XCUIElementTypeWindow\", secondLevelTag=\"XCUIElementTypeButton\", thirdLevelTag=\"XCUIElementTypeStaticText\", thirdLevelValue=None, thirdLevelName=None, ): CommonAttrs_VisibleEnabledFullWidthFullHeight = {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % self.X, \"height\": \"%s\" % self.totalY} commonItemChainList = [ { \"tag\": firstLevelTag, \"attrs\": CommonAttrs_VisibleEnabledFullWidthFullHeight }, { \"tag\": secondLevelTag, \"attrs\": CommonAttrs_VisibleEnabledFullWidthFullHeight }, ] thirdItemAttrs = {\"visible\":\"true\", \"enabled\":\"true\"} if thirdLevelValue: thirdItemAttrs[\"value\"] = thirdLevelValue if thirdLevelName: thirdItemAttrs[\"name\"] = thirdLevelName thirdItemDict = { \"tag\": thirdLevelTag, \"attrs\": thirdItemAttrs } commonItemChainList.append(thirdItemDict) return commonItemChainList crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 22:50:21 "},"common_code/first_run_guide.html":{"url":"common_code/first_run_guide.html","title":"首次登录引导页","keywords":"","body":"首次登录引导页 首次登录app时，引导页，多次左滑进入app主页 def swipeLeftGuideToMain(self): \"\"\" 处理iOS中app，在首次登录后，引导页，需要多次左滑，最后进入主页 \"\"\" \"\"\" 途虎养车 左滑引导页 1页/3页： 途虎养车 左滑引导页 2页/3页： 途虎养车 左滑引导页 3页/3页 立即进入： \"\"\" # GuideText = \"guide\" # parentScrollViewClassChain = \"/XCUIElementTypeScrollView[`rect.x = 0 AND rect.y = 0 AND rect.width = %d AND rect.height = %d`]\" % (ScreenX, ScreenY) # guideImgeQuery = {\"type\":\"XCUIElementTypeImage\", \"nameContains\": GuideText, \"enabled\": \"true\", \"x\":\"0\", \"y\":\"0\", \"width\": \"%s\" % ScreenX, \"height\":\"%s\" % ScreenY} # guideImgeQuery[\"parent_class_chains\"] = [ parentScrollViewClassChain ] # isFound, guideImgeElement = findElement(curSession, guideImgeQuery, timeout=0.1) # if isFound: # # foundAndClicked = clickElement(curSession, guideImgeElement) # swipeLeft(curSession) foundAndSwipeGuideToMain = False swipeNum = 0 guideP = re.compile(\"guide\") # guide0, guide1, guide2 guideImageChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": self.FullScreenAttrDict, }, { \"tag\": \"XCUIElementTypeScrollView\", \"attrs\": self.FullScreenAttrDict, }, { \"tag\": \"XCUIElementTypeImage\", \"attrs\": {\"name\": guideP, **self.FullScreenAttrDict} }, ] while True: curPageXml = self.get_page_source() soup = CommonUtils.xmlToSoup(curPageXml) guideImageSoup = CommonUtils.bsChainFind(soup, guideImageChainList) if not guideImageSoup: break parentScrollViewSoup = guideImageSoup.parent if not parentScrollViewSoup: break validButtonSoupList = [] nextSiblingList = parentScrollViewSoup.next_siblings for eachNextSiblingSoup in nextSiblingList: if hasattr(eachNextSiblingSoup, \"attrs\"): soupAttrDict = eachNextSiblingSoup.attrs # {'enabled': 'true', 'height': '30', 'label': 'loading btn', 'name': 'loading btn', 'type': 'XCUIElementTypeButton', 'visible': 'true', 'width': '132', 'x': '141', 'y': '628'} soupType = soupAttrDict.get(\"type\") # 'XCUIElementTypeButton' soupName = soupAttrDict.get(\"name\") # 'loading btn' soupVisible = soupAttrDict.get(\"visible\") # 'true' isButton = soupType == \"XCUIElementTypeButton\" # isLoadingName = bool(re.search(soupName, \"loading\")) isLoadingName = bool(re.search(\"loading\", soupName)) isVisible = soupVisible == \"true\" isValid = isButton and isLoadingName and isVisible if isValid: validButtonSoupList.append(eachNextSiblingSoup) if validButtonSoupList: validButtonNum = len(validButtonSoupList) if validButtonNum == 1: # end page, click button, into main page lastPageButtonSoup = validButtonSoupList[0] self.clickElementCenterPosition(lastPageButtonSoup) foundAndSwipeGuideToMain = True break elif validButtonNum > 1: swipeNum += 1 # not end, should continue to swipe left self.swipe(\"SwipeLeft\") logging.info(\"Swipe left for guide page %d\", swipeNum) return foundAndSwipeGuideToMain 对应页面： 恒易贷 第一页： 最后一页： 途虎养车 第一页 第二页 第三页 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 22:38:16 "},"source_analysis/":{"url":"source_analysis/","title":"源码分析","keywords":"","body":"源码分析 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 22:00:14 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-01 18:17:10 "},"appendix/doc.html":{"url":"appendix/doc.html","title":"文档","keywords":"","body":"文档 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 22:38:34 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【已解决】Mac中用facebook-wda自动化测试操作iOS设备 【已解决】Mac中用facebook-wda操作iOS真机iPhone6 【已解决】Mac中xcodebuild警告：xcode-select error tool xcodebuild requires Xcode 【未解决】自动抓包iOS的app：左滑引导页进入首页 【已解决】自动抓包工具适配iOS：当前检测出微信连续异常，你可以尝试一下方法修复 下一步 crifan (Crifan Li) 【记录】给Gitbook添加更多配置和功能 【已解决】提取Gitbook中Makefile公共部分 【已解决】gitbook中book.json中能否把公共部分提取出来 端口转发 · 苹果相关开发总结 ATX 文档 - iOS 真机如何安装 WebDriverAgent · TesterHome ATX 系列-如何测试网易云音乐 (iOS 篇) · TesterHome 使用 Python 库 facebook-wda 完成网易云音乐 iOS 客户端的自动化测试 (示例) · TesterHome ATX 文档 - iOS 控件操作 API · TesterHome iOS 自动化测试 · TesterHome 【IOS测试】一篇读懂自动化框架WebDriverAgent – Python量化投资 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-20 23:10:39 "}}