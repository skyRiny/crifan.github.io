{"./":{"url":"./","title":"前言","keywords":"","body":"Python常用代码段 最新版本：v1.0 更新时间：20200627 鸣谢 感谢我的老婆陈雪的包容理解和悉心照料，才使得我crifan有更多精力去专注技术专研和整理归纳出这些电子书和技术教程，特此鸣谢。 简介 整理出crifan总结的Python各个方面常用的代码段，供需要的参考。包括通用逻辑、变量、系统、日期时间、字符和字符串、文件系统，比如文件和文件夹等、以及第三方库，比如BeautifulSoup、以及多媒体音视频类、包括Pillow、以及网络的Requests等；以及其他常见语法，包括dict字典、list列表、set集合、enum枚举、collections集合等。 源码+浏览+下载 本书的各种源码、在线浏览地址、多种格式文件下载如下： Gitbook源码 crifan/python_common_code_snippet: Python常用代码段 如何使用此Gitbook源码去生成发布为电子书 详见：crifan/gitbook_template: demo how to use crifan gitbook template and demo 在线浏览 Python常用代码段 book.crifan.com Python常用代码段 crifan.github.io 离线下载阅读 Python常用代码段 PDF Python常用代码段 ePub Python常用代码段 Mobi 版权说明 此电子书教程的全部内容，如无特别说明，均为本人原创和整理。其中部分内容参考自网络，均已备注了出处。如有发现侵犯您版权，请通过邮箱联系我 admin 艾特 crifan.com，我会尽快删除。谢谢合作。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 20:31:12 "},"background/":{"url":"background/","title":"背景","keywords":"","body":"背景 多年的技术开发，积累了很多关于 Python 的常用的一些函数和功能，都已整理到对应的函数库中： https://github.com/crifan/crifanLibPython 且也给出了很多函数的demo演示如何使用： https://github.com/crifan/crifanLibPython/tree/master/crifanLib/demo 但还是解释的不够清楚和全面。 故此处专门把Python的常用的代码段和调用举例，都整理至此，详细解释。 目的： 方便需要时能快速查阅：直接看代码，一看就懂，无需额外解释。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 20:21:05 "},"common_code/":{"url":"common_code/","title":"常用代码段","keywords":"","body":"常用代码段 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 10:18:39 "},"common_code/common_logic.html":{"url":"common_code/common_logic.html","title":"通用逻辑","keywords":"","body":"通用逻辑 多次运行一个函数，直到成功运行 执行一个函数（可能有多个可变数量的参数），且尝试多次，直到成功或超出最大此时，最终实现是： def multipleRetry(functionInfoDict, maxRetryNum=5, sleepInterval=0.1, isShowErrWhenFail=True): \"\"\" do something, retry mutiple time if fail Args: functionInfoDict (dict): function info dict contain functionCallback and [optional] functionParaDict maxRetryNum (int): max retry number sleepInterval (float): sleep time of each interval when fail isShowErrWhenFail (bool): show error when fail if true Returns: bool Raises: \"\"\" doSuccess = False functionCallback = functionInfoDict[\"functionCallback\"] functionParaDict = functionInfoDict.get(\"functionParaDict\", None) curRetryNum = maxRetryNum while curRetryNum > 0: if functionParaDict: doSuccess = functionCallback(**functionParaDict) else: doSuccess = functionCallback() if doSuccess: break time.sleep(sleepInterval) curRetryNum -= 1 if not doSuccess: if isShowErrWhenFail: functionName = str(functionCallback) # '>' logging.error(\"Still fail after %d retry for %s\", maxRetryNum, functionName) return doSuccess 说明： functionCallback函数类型都要符合：返回值是bool类型才可以 调用举例： （1）没有额外参数 foundAndClickedWifi = CommonUtils.multipleRetry({\"functionCallback\": self.iOSFromSettingsIntoWifiList}) 其中： def iOSFromSettingsIntoWifiList(self): 。。。 foundAndClickedWifi = self.findAndClickElement(query=wifiTextQuery, timeout=0.1) return foundAndClickedWifi 类似例子： isSwitchOk = self.multipleRetry({\"functionCallback\": self.switchToAppStoreSearchTab}) 对比之前原始写法： isSwitchOk = self.switchToAppStoreSearchTab() 其他类似例子： foundAndClickedDownload = self.multipleRetry({\"functionCallback\": self.appStoreStartDownload}) 详见： 【已解决】AppStore自动安装iOS的app：逻辑优化加等待和多试几次 （2）有额外参数，参数个数：2个 searchInputQuery = {\"type\":\"XCUIElementTypeSearchField\", \"name\":\"App Store\"} isInputOk = CommonUtils.multipleRetry( { \"functionCallback\": self.wait_element_setText, \"functionParaDict\": { \"locator\": searchInputQuery, \"text\": appName, } } ) 对比之前原始写法： searchInputQuery = {\"type\":\"XCUIElementTypeSearchField\", \"name\":\"App Store\"} isInputOk = self.wait_element_setText(searchInputQuery, appName) 其中wait_element_setText的定义是： def wait_element_setText(self, locator, text): 对应着之前传入时的： \"functionParaDict\": { \"locator\": searchInputQuery, \"text\": appName, } （3）有额外参数，且加上multipleRetry的额外参数 isSwitchOk = CommonUtils.multipleRetry( {\"functionCallback\": self.switchToAppStoreSearchTab}, maxRetryNum = 10, sleepInterval = 0.5, ) 以及类似的： isIntoDetailOk = self.multipleRetry( { \"functionCallback\": self.appStoreSearchResultIntoDetail, \"functionParaDict\": { \"appName\": appName, } }, sleepInterval=0.5 ) 之前原始写法： isIntoDetailOk = self.appStoreSearchResultIntoDetail(appName) 注： 此处是后来加上的 sleepInterval=0.5 是因为后来遇到了，即使尝试了5次，依旧没找到，所以增加了没找到的延迟等待时间。 详见： 【已解决】AppStore自动安装iOS的app：逻辑优化加等待和多试几次 （4） isIntoDetailOk = CommonUtils.multipleRetry( { \"functionCallback\": self.appStoreSearchResultIntoDetail, \"functionParaDict\": { \"appName\": appName, } }, maxRetryNum = 10, sleepInterval = 0.5, ) crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:23:18 "},"common_code/variable.html":{"url":"common_code/variable.html","title":"变量","keywords":"","body":"变量 判断变量类型 优先用isinstance，而不是type >>> isinstance(2, float) False >>> isinstance('a', (str, unicode)) True >>> isinstance((2, 3), (str, list, tuple)) True crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:24:15 "},"common_code/system.html":{"url":"common_code/system.html","title":"系统","keywords":"","body":"系统 此处整理用Python处理系统相关的通用的代码。 系统类型 import sys def osIsWinows(): return sys.platform == \"win32\" def osIsCygwin(): return sys.platform == \"cygwin\" def osIsMacOS(): return sys.platform == \"darwin\" def osIsLinux(): return sys.platform == \"linux\" def osIsAix(): return sys.platform == \"aix\" 命令行 获取命令行执行命令返回结果 代码： def get_cmd_lines(cmd, text=False): # 执行cmd命令，将结果保存为列表 resultStr = \"\" resultStrList = [] try: consoleOutputByte = subprocess.check_output(cmd, shell=True) # b'C02Y3N10JHC8\\n' try: resultStr = consoleOutputByte.decode(\"utf-8\") except UnicodeDecodeError: # TODO: use chardet auto detect encoding # consoleOutputStr = consoleOutputByte.decode(\"gbk\") resultStr = consoleOutputByte.decode(\"gb18030\") if not text: resultStrList = resultStr.splitlines() except Exception as err: print(\"err=%s when run cmd=%s\" % (err, cmd)) if text: return resultStr else: return resultStrList 硬件信息 获取当前电脑（Win或Mac）的序列号 代码： def getSerialNumber(self): \"\"\"get current computer serial number\"\"\" # cmd = \"wmic bios get serialnumber\" cmd = \"\" if CommonUtils.osIsWinows(): # Windows cmd = \"wmic bios get serialnumber\" elif CommonUtils.osIsMacOS(): # macOS cmd = \"system_profiler SPHardwareDataType | awk '/Serial/ {print $4}'\" # TODO: add support other OS # AIX: aix # Linux: linux # Windows/Cygwin: cygwin serialNumber = \"\" lines = CommonUtils.get_cmd_lines(cmd) if CommonUtils.osIsWinows(): # Windows serialNumber = lines[1] elif CommonUtils.osIsMacOS(): # macOS serialNumber = lines[0] # C02Y3N10JHC8 return serialNumber crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 10:24:06 "},"common_code/date_time.html":{"url":"common_code/date_time.html","title":"日期时间","keywords":"","body":"日期时间 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanDatetime.py getCurDatetimeStr 生成当前日期时间字符串 def getCurDatetimeStr(outputFormat=\"%Y%m%d_%H%M%S\"): \"\"\" get current datetime then format to string eg: 20171111_220722 :param outputFormat: datetime output format :return: current datetime formatted string \"\"\" curDatetime = datetime.now() # 2017-11-11 22:07:22.705101 curDatetimeStr = curDatetime.strftime(format=outputFormat) #'20171111_220722' return curDatetimeStr 调用举例： curDatetimeStr = getCurDatetimeStr() # '20191219_143400' datetime转时间戳 import time def datetimeToTimestamp(self, datetimeVal, withMilliseconds=False) : \"\"\" convert datetime value to timestamp eg: \"2006-06-01 00:00:00.123\" -> 1149091200 if with milliseconds -> 1149091200123 :param datetimeVal: :return: \"\"\" timetupleValue = datetimeVal.timetuple() timestampFloat = time.mktime(timetupleValue) # 1531468736.0 -> 10 digits timestamp10DigitInt = int(timestampFloat) # 1531468736 timestampInt = timestamp10DigitInt if withMilliseconds: microsecondInt = datetimeVal.microsecond # 817762 microsecondFloat = float(microsecondInt)/float(1000000) # 0.817762 timestampFloat = timestampFloat + microsecondFloat # 1531468736.817762 timestampFloat = timestampFloat * 1000 # 1531468736817.7621 -> 13 digits timestamp13DigitInt = int(timestampFloat) # 1531468736817 timestampInt = timestamp13DigitInt return timestampInt 获取当前时间戳 from datetime import datetime def getCurTimestamp(withMilliseconds=False): \"\"\" get current time's timestamp (default)not milliseconds -> 10 digits: 1351670162 with milliseconds -> 13 digits: 1531464292921 \"\"\" curDatetime = datetime.now() return datetimeToTimestamp(curDatetime, withMilliseconds) 时间戳精确到毫秒 from datetime import datetime,timedelta timestampStr = datetime.now().strftime(\"%Y%m%d_%H%M%S_%f\") # 20180712_154134_660436 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:34:28 "},"common_code/char_string.html":{"url":"common_code/char_string.html","title":"字符和字符串","keywords":"","body":"字符和字符串 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanFile.py Python3 str转bytes Python 3中，把字符串转换成字节码，可以有两种写法： 方法1：用bytes去转换 convertedBytes = bytes(originStr) 方法2：用字符串str的编码encode encodedBytes = originStr.encode() 其中： 都有额外的encoding参数： 由于默认都是UTF-8 所以可加可不加 也可以根据需要，去加其他你要的编码 如果要加，就是： convertedBytes = bytes(originStr, \"UTF-8\") encodedBytes = originStr.encode(\"UTF-8\") 字符串格式化为人类易读格式 def formatSize(sizeInBytes, decimalNum=1, isUnitWithI=False, sizeUnitSeperator=\"\"): \"\"\" format size to human readable string example: 3746 -> 3.7KB 87533 -> 85.5KiB 98654 -> 96.3 KB 352 -> 352.0B 76383285 -> 72.84MB 763832854988542 -> 694.70TB 763832854988542665 -> 678.4199PB refer: https://stackoverflow.com/questions/1094841/reusable-library-to-get-human-readable-version-of-file-size \"\"\" # https://en.wikipedia.org/wiki/Binary_prefix#Specific_units_of_IEC_60027-2_A.2_and_ISO.2FIEC_80000 # K=kilo, M=mega, G=giga, T=tera, P=peta, E=exa, Z=zetta, Y=yotta sizeUnitList = ['','K','M','G','T','P','E','Z'] largestUnit = 'Y' if isUnitWithI: sizeUnitListWithI = [] for curIdx, eachUnit in enumerate(sizeUnitList): unitWithI = eachUnit if curIdx >= 1: unitWithI += 'i' sizeUnitListWithI.append(unitWithI) # sizeUnitListWithI = ['','Ki','Mi','Gi','Ti','Pi','Ei','Zi'] sizeUnitList = sizeUnitListWithI largestUnit += 'i' suffix = \"B\" decimalFormat = \".\" + str(decimalNum) + \"f\" # \".1f\" finalFormat = \"%\" + decimalFormat + sizeUnitSeperator + \"%s%s\" # \"%.1f%s%s\" sizeNum = sizeInBytes for sizeUnit in sizeUnitList: if abs(sizeNum) 调用： def testKb(): kbSize = 3746 kbStr = formatSize(kbSize) print(\"%s -&gt; %s\" % (kbSize, kbStr)) def testI(): iSize = 87533 iStr = formatSize(iSize, isUnitWithI=True) print(\"%s -&gt; %s\" % (iSize, iStr)) def testSeparator(): seperatorSize = 98654 seperatorStr = formatSize(seperatorSize, sizeUnitSeperator=\" \") print(\"%s -&gt; %s\" % (seperatorSize, seperatorStr)) def testBytes(): bytesSize = 352 bytesStr = formatSize(bytesSize) print(\"%s -&gt; %s\" % (bytesSize, bytesStr)) def testMb(): mbSize = 76383285 mbStr = formatSize(mbSize, decimalNum=2) print(\"%s -&gt; %s\" % (mbSize, mbStr)) def testTb(): tbSize = 763832854988542 tbStr = formatSize(tbSize, decimalNum=2) print(\"%s -&gt; %s\" % (tbSize, tbStr)) def testPb(): pbSize = 763832854988542665 pbStr = formatSize(pbSize, decimalNum=4) print(\"%s -&gt; %s\" % (pbSize, pbStr)) def demoFormatSize(): testKb() testI() testSeparator() testBytes() testMb() testTb() testPb() crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:32:33 "},"common_code/file_system/":{"url":"common_code/file_system/","title":"文件系统","keywords":"","body":"文件系统 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanFile.py https://github.com/crifan/crifanLibPython/blob/master/crifanLib/demo/crifanFileDemo.py crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:56:10 "},"common_code/file_system/file.html":{"url":"common_code/file_system/file.html","title":"文件","keywords":"","body":"文件 提取文件名后缀 def extractSuffix(fileNameOrUrl): \"\"\" extract file suffix from name or url eg: https://cdn2.qupeiyin.cn/2018-09-10/15365514898246.mp4 -> mp4 15365514894833.srt -> srt \"\"\" return fileNameOrUrl.split('.')[-1] 创建空文件 import os def createEmptyFile(fullFilename): \"\"\"Create a empty file like touch\"\"\" filePath = os.path.dirname(fullFilename) # create folder if not exist if not os.path.exists(filePath): os.makedirs(filePath) with open(fullFilename, 'a'): # Note: not use 'w' for maybe conflict for others constantly writing to it os.utime(fullFilename, None) 保存（二进制）数据到文件 def saveDataToFile(fullFilename, binaryData): \"\"\"save binary data info file\"\"\" with open(fullFilename, 'wb') as fp: fp.write(binaryData) fp.close() # print(\"Complete save file %s\" % fullFilename) 保存json到文件 import json import codecs def saveJsonToFile(fullFilename, jsonValue): \"\"\"save json dict into file\"\"\" with codecs.open(fullFilename, 'w', encoding=\"utf-8\") as jsonFp: json.dump(jsonValue, jsonFp, indent=2, ensure_ascii=False) # print(\"Complete save json %s\" % fullFilename) 从文件中加载出json import json import codecs def loadJsonFromFile(fullFilename): \"\"\"load and parse json dict from file\"\"\" with codecs.open(fullFilename, 'r', encoding=\"utf-8\") as jsonFp: jsonDict = json.load(jsonFp) # print(\"Complete load json from %s\" % fullFilename) return jsonDict 通过二进制生成文件类型对象 （1）Python 3 import io audioBinaryData = audioObj.read() audioFileLikeObj = io.BytesIO(audioBinaryData) 得到对应的文件类型的对象的：，即可去像操作文件一样去操作这个io。 （2）Python 2 import StringIO audioFileLikeObj = StringIO.StringIO() audioFileLikeObj.write(audioBinaryData) 一行代码把字符串写入保存到文件 open(fullFilePath, \"w\").write(fileContentStr).close() 举例： open(\"0408_1600.xml\", \"w\").write(page).close() 给文件增加可执行权限：实现chmod +x的效果 代码： import os import stat curState = os.stat(someFile) newState = curState.st_mode | stat.S_IEXEC os.chmod(someFile, newState) 再去优化为函数： import os import stat def chmodAddX(someFile): \"\"\"add file executable mode, like chmod +x Args: someFile (str): file full path Returns: soup Raises: \"\"\" if os.path.exists(someFile): if os.path.isfile(someFile): # add executable curState = os.stat(someFile) newState = curState.st_mode | stat.S_IEXEC os.chmod(someFile, newState) 调用： chmodAddX(shellFullPath) 继续优化： 参考 How do you do a simple \"chmod +x\" from within python? - Stack Overflow 如果想要加上，给任何人都有可执行权限，则可以用： def chmodAddX(someFile): \"\"\"add file executable mode, like chmod +x Args: someFile (str): file full path Returns: soup Raises: \"\"\" if os.path.exists(someFile): if os.path.isfile(someFile): # add executable curState = os.stat(someFile) # STAT_OWNER_EXECUTABLE = stat.S_IEXEC # executableMode = STAT_OWNER_EXECUTABLE STAT_EVERYONE_EXECUTABLE = stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH executableMode = STAT_EVERYONE_EXECUTABLE newState = curState.st_mode | executableMode os.chmod(someFile, newState) 效果： 之前：-rw-r--r-- 之后：-rwxr-xr-x 给 user group other 都加上x的可执行权限 详见： 【已解决】Python中给Mac中文件加上可执行权限 判断是否是文件对象 import sys def isFileObject(fileObj): \"\"\"\"check is file like object or not\"\"\" if sys.version_info[0] == 2: return isinstance(fileObj, file) else: # for python 3: # has read() method for: # io.IOBase # io.BytesIO # io.StringIO # io.RawIOBase return hasattr(fileObj, 'read') 计算当前文件名，如果重名，则位数加1 import os import re def findNextNumberFilename(curFilename): \"\"\"Find the next available filename from current name Args: curFilename (str): current filename Returns: next available (not existed) filename Raises: Examples: (1) 'crifanLib/demo/input/image/20201219_172616_drawRect_40x40.jpg' not exist -> 'crifanLib/demo/input/image/20201219_172616_drawRect_40x40.jpg' (2) 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40.jpg' exsit -> next until not exist 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40_3.jpg' \"\"\" newFilename = curFilename newPathRootPart, pointSuffix = os.path.splitext(newFilename) # 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40_1' filenamePrefix = newPathRootPart while os.path.exists(newFilename): newTailNumberInt = 1 foundTailNumber = re.search(\"^(?P.+)_(?P\\d+)$\", newPathRootPart) if foundTailNumber: tailNumberStr = foundTailNumber.group(\"tailNumber\") # '1' tailNumberInt = int(tailNumberStr) newTailNumberInt = tailNumberInt + 1 # 2 filenamePrefix = foundTailNumber.group(\"filenamePrefix\") # 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40' # existed previously saved, change to new name newPathRootPart = \"%s_%s\" % (filenamePrefix, newTailNumberInt) # 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40_2' newFilename = newPathRootPart + pointSuffix # 'crifanLib/demo/input/image/20191219_172616_drawRect_40x40_2.jpg' return newFilename 调用： notExistFile = \"crifanLib/demo/input/image/some_not_exist_filename.jpg\" nextFilename = findNextNumberFilename(notExistFile) print(\"notExistFile=%s -> nextFilename=%s\" % (notExistFile, nextFilename)) # notExistFile=crifanLib/demo/input/image/some_not_exist_filename.jpg -> nextFilename=crifanLib/demo/input/image/some_not_exist_filename.jpg realExistFile = \"crifanLib/demo/input/image/20191219_172616_drawRect_40x40.jpg\" nextUntilNotExistFilename = findNextNumberFilename(realExistFile) print(\"realExistFile=%s -> nextUntilNotExistFilename=%s\" % (realExistFile, nextUntilNotExistFilename)) # realExistFile=crifanLib/demo/input/image/20191219_172616_drawRect_40x40.jpg -> nextUntilNotExistFilename=crifanLib/demo/input/image/20191219_172616_drawRect_40x40_2.jpg 从文件名后缀推断出MIME类型 用库： mime GitHub https://github.com/liluo/mime 安装mime： pip install mime 代码： import mime fileMimeType = mime.Types.of(curAudioFullFilename)[0].content_type 输入文件：'Lots of Hearts.mp3' 输出信息：'audio/mpeg' crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:56:22 "},"common_code/file_system/folder.html":{"url":"common_code/file_system/folder.html","title":"文件夹","keywords":"","body":"文件夹=文件路径 新建文件夹 对于：python 3.2+ import os def createFolder(folderFullPath): \"\"\" create folder, even if already existed Note: for Python 3.2+ \"\"\" os.makedirs(folderFullPath, exist_ok=True) # print(\"Created folder: %s\" % folderFullPath) 或： 对于：python 3.5+ import pathlib pathlib.Path('/my/directory').mkdir(parents=True, exist_ok=True) 批量删除非空文件夹 import shutil if os.path.exists(folderToDelete): shutil.rmtree(folderToDelete) 注意： 删除之前要先用os.path.exists判断是非存在该目录 如果不存在就去删除，则会报错：OSError: [Errno 2] No such file or directory os.path 路径处理 #!/usr/bin/python # -*- coding: utf-8 -*- # Author: Crifan Li # Update: 20191219 # Function: Demo os.path common used functions import os def osPathDemo(): currentSystemInfo = os.uname() print(\"currentSystemInfo=%s\" % (currentSystemInfo, )) # currentSystemInfo=posix.uname_result(sysname='Darwin', nodename='xxx', release='18.7.0', version='Darwin Kernel Version 18.7.0: Sat Oct 12 00:02:19 PDT 2019; root:xnu-4903.278.12~1/RELEASE_X86_64', machine='x86_64') pathSeparatorInCurrentOS = os.path.sep print(\"pathSeparatorInCurrentOS=%s\" % pathSeparatorInCurrentOS) # pathSeparatorInCurrentOS=/ fullFilePath = \"/Users/limao/dev/crifan/python/notEnoughUnpack/Snip20191212_113.png\" print(\"fullFilePath=%s\" % fullFilePath) # fullFilePath=/Users/limao/dev/crifan/python/notEnoughUnpack/Snip20191212_113.png dirname = os.path.dirname(fullFilePath) print(\"dirname=%s\" % dirname) # dirname=/Users/limao/dev/crifan/python/notEnoughUnpack basename = os.path.basename(fullFilePath) print(\"basename=%s\" % basename) # basename=Snip20191212_113.png joinedFullPath = os.path.join(dirname, basename) print(\"joinedFullPath=%s\" % joinedFullPath) # joinedFullPath=/Users/limao/dev/crifan/python/notEnoughUnpack/Snip20191212_113.png isSame = (fullFilePath == joinedFullPath) print(\"isSame=%s\" % isSame) # isSame=True root, pointSuffix = os.path.splitext(fullFilePath) print(\"root=%s, pointSuffix=%s\" % (root, pointSuffix)) # root=/Users/limao/dev/crifan/python/notEnoughUnpack/Snip20191212_113, pointSuffix=.png head, tail = os.path.split(fullFilePath) print(\"head=%s, tail=%s\" % (head, tail)) # head=/Users/limao/dev/crifan/python/notEnoughUnpack, tail=Snip20191212_113.png drive, tail = os.path.splitdrive(fullFilePath) print(\"drive=%s, tail=%s\" % (drive, tail)) # drive=, tail=/Users/limao/dev/crifan/python/notEnoughUnpack/Snip20191212_113.png curPath = os.getcwd() print(\"curPath=%s\" % curPath) # curPath=/Users/limao/dev/crifan/python relativePath = os.path.relpath(fullFilePath) print(\"relativePath=%s\" % relativePath) # relativePath=notEnoughUnpack/Snip20191212_113.png isFile = os.path.isfile(fullFilePath) print(\"isFile=%s\" % isFile) # isFile=True isDirectory = os.path.isdir(fullFilePath) print(\"isDirectory=%s\" % isDirectory) # isDirectory=False fileSize = os.path.getsize(fullFilePath) print(\"fileSize=%s\" % fileSize) # fileSize=368810 isFileOrFolderRealExist = os.path.exists(fullFilePath) print(\"isFileOrFolderRealExist=%s\" % isFileOrFolderRealExist) # isFileOrFolderRealExist=True if __name__ == \"__main__\": osPathDemo() crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:55:42 "},"common_code/beautifulSoup.html":{"url":"common_code/beautifulSoup.html","title":"BeautifulSoup","keywords":"","body":"BeautifulSoup 从xml转换出soup 背景： iOS自动化期间，常会涉及到，获取到当前页面源码，是xml字符串，需要转换为soup，才能后续操作 所以整理出通用转换逻辑 def xmlToSoup(xmlStr): \"\"\"convert to xml string to soup Note: xml is tag case sensitive -> retain tag upper case -> NOT convert tag to lowercase Args: xmlStr (str): xml str, normally page source Returns: soup Raises: \"\"\" # HtmlParser = 'html.parser' # XmlParser = 'xml' XmlParser = 'lxml-xml' curParser = XmlParser soup = BeautifulSoup(xmlStr, curParser) return soup 举例： （1） curPageXml = self.get_page_source() soup = CommonUtils.xmlToSoup(curPageXml) 获取到xml字符串后，去转换为soup 是否包含符合特定条件的soup节点 def isContainSpecificSoup(soupList, elementName, isSizeValidCallback, matchNum=1): \"\"\" 判断BeautifulSoup的soup的list中，是否包含符合条件的特定的元素： 只匹配指定个数的元素才视为找到了 元素名相同 面积大小是否符合条件 Args: elementName (str): element name isSizeValidCallback (function): callback function to check whether element size(width * height) is valid or not matchNum (int): sould only matched specific number consider as valid Returns: bool Raises: \"\"\" isFound = False matchedSoupList = [] for eachSoup in soupList: # if hasattr(eachSoup, \"tag\"): if hasattr(eachSoup, \"name\"): # curSoupTag = eachSoup.tag curSoupTag = eachSoup.name if curSoupTag == elementName: if hasattr(eachSoup, \"attrs\"): soupAttr = eachSoup.attrs soupWidth = int(soupAttr[\"width\"]) soupHeight = int(soupAttr[\"height\"]) curSoupSize = soupWidth * soupHeight # 326 * 270 isSizeValid = isSizeValidCallback(curSoupSize) if isSizeValid: matchedSoupList.append(eachSoup) matchedSoupNum = len(matchedSoupList) if matchNum == 0: isFound = True else: if matchedSoupNum == matchNum: isFound = True return isFound 说明： 判断soup内，是否有符合特定条件的soup 举例： （1）iOS的弹框，有上角带关闭按钮时，去判断一个弹框，是否符合对应条件，以便于判断是否可能是弹框 nextSiblingeSoupGenerator = possibleCloseSoup.next_siblings nextSiblingeSoupList = list(nextSiblingeSoupGenerator) hasLargeImage = CommonUtils.isContainSpecificSoup(nextSiblingeSoupList, \"XCUIElementTypeImage\", self.isPopupWindowSize) isPossibleClose = hasLargeImage 相关函数 def isPopupWindowSize(self, curSize): \"\"\"判断一个soup的宽高大小是否是弹框类窗口(Image,Other等）的大小\"\"\" # global FullScreenSize FullScreenSize = self.X * self.totalY curSizeRatio = curSize / FullScreenSize # 0.289 PopupWindowSizeMinRatio = 0.25 # PopupWindowSizeMaxRatio = 0.9 PopupWindowSizeMaxRatio = 0.8 # isSizeValid = curSizeRatio >= MinPopupWindowSizeRatio # is popup like window, size should large enough, but should not full screen isSizeValid = PopupWindowSizeMinRatio （2） hasNormalButton = CommonUtils.isContainSpecificSoup(nextSiblingeSoupList, \"XCUIElementTypeButton\", self.isNormalButtonSize) 相关函数： def isNormalButtonSize(self, curSize): \"\"\"判断一个soup的宽高大小是否是普通的按钮大小\"\"\" NormalButtonSizeMin = 30*30 NormalButtonSizeMax = 100*100 isNormalSize = NormalButtonSizeMin 查找元素，限定条件是符合对应的几级的父元素的条件 背景： 很多时候，需要对于iOS的app的页面的源码，即xml中，查找符合特定情况的的元素 这些特定情况，往往是parent或者前几层级的parent中，元素符合一定条件，往往是type，以及宽度是屏幕宽度，高度是屏幕高度等等 所以提取出公共函数，用于bs的find查找元素 def bsChainFind(curLevelSoup, queryChainList): \"\"\"BeautifulSoup find with query chain Args: curLevelSoup (soup): BeautifulSoup queryChainList (list): str list of all level query dict Returns: soup Raises: Examples: input: [ { \"tag\": \"XCUIElementTypeWindow\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % ScreenX, \"height\": \"%s\" % ScreenY} }, { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % ScreenX, \"height\": \"%s\" % ScreenY} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"可能离开微信，打开第三方应用\"} }, ] output: soup node of in : \"\"\" foundSoup = None if queryChainList: chainListLen = len(queryChainList) if chainListLen == 1: # last one curLevelFindDict = queryChainList[0] curTag = curLevelFindDict[\"tag\"] curAttrs = curLevelFindDict[\"attrs\"] foundSoup = curLevelSoup.find(curTag, attrs=curAttrs) else: highestLevelFindDict = queryChainList[0] curTag = highestLevelFindDict[\"tag\"] curAttrs = highestLevelFindDict[\"attrs\"] foundSoupList = curLevelSoup.find_all(curTag, attrs=curAttrs) if foundSoupList: childrenChainList = queryChainList[1:] for eachSoup in foundSoupList: eachSoupResult = CommonUtils.bsChainFind(eachSoup, childrenChainList) if eachSoupResult: foundSoup = eachSoupResult break return foundSoup 举例： （1） \"\"\" 微信-小程序 弹框 警告 尚未进行授权： \"\"\" warningChainList = [ { \"tag\": \"XCUIElementTypeButton\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"width\": \"%s\" % self.X, \"height\": \"%s\" % self.totalY} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"visible\":\"true\", \"enabled\":\"true\", \"value\":\"警告\"} }, ] warningSoup = CommonUtils.bsChainFind(soup, warningChainList) 相关： 找到元素后，再去点击： if warningSoup: parentOtherSoup = warningSoup.parent confirmSoup = parentOtherSoup.find( \"XCUIElementTypeButton\", attrs={\"visible\":\"true\", \"enabled\":\"true\", \"name\": \"确定\"} ) if confirmSoup: self.clickElementCenterPosition(confirmSoup) foundAndProcessedPopup = True （2） \"\"\" 系统弹框 拍照或录像： \"\"\" photoCameraChainList = [ { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeTable\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"y\":\"0\"} }, { \"tag\": \"XCUIElementTypeStaticText\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"value\":\"拍照或录像\"} }, ] photoCameraSoup = CommonUtils.bsChainFind(soup, photoCameraChainList) （3）iOS 设置 无线局域网 列表页 找 当前已连接的WiFi，特征是带蓝色✅的： \"\"\" 设置 无线局域网 列表页： 。。。 \"\"\" curPageXml = self.get_page_source() soup = CommonUtils.xmlToSoup(curPageXml) blueCheckChainList = [ { \"tag\": \"XCUIElementTypeCell\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"x\":\"0\", \"width\":\"%s\" % self.X} }, { \"tag\": \"XCUIElementTypeOther\", \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\"} }, { \"tag\": \"XCUIElementTypeImage\", # \"attrs\": {\"enabled\":\"true\", \"visible\":\"true\", \"name\": \"UIPreferencesBlueCheck\"} \"attrs\": {\"enabled\":\"true\", \"name\": \"UIPreferencesBlueCheck\"} }, ] blueCheckSoup = CommonUtils.bsChainFind(soup, blueCheckChainList) if blueCheckSoup: crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:31:23 "},"common_code/multimedia.html":{"url":"common_code/multimedia.html","title":"多媒体","keywords":"","body":"多媒体 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:51:07 "},"common_code/image.html":{"url":"common_code/image.html","title":"图像","keywords":"","body":"图像 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanMultimedia.py https://github.com/crifan/crifanLibPython/blob/master/crifanLib/demo/crifanMultimediaDemo.py 缩放图片 import io from PIL import Image, ImageDraw def resizeImage(inputImage, newSize, resample=Image.BICUBIC, # Image.LANCZOS, outputFormat=None, outputImageFile=None ): \"\"\" resize input image resize normally means become smaller, reduce size :param inputImage: image file object(fp) / filename / binary bytes :param newSize: (width, height) :param resample: PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC, or PIL.Image.LANCZOS https://pillow.readthedocs.io/en/stable/reference/Image.html#PIL.Image.Image.thumbnail :param outputFormat: PNG/JPEG/BMP/GIF/TIFF/WebP/..., more refer: https://pillow.readthedocs.io/en/stable/handbook/image-file-formats.html if input image is filename with suffix, can omit this -> will infer from filename suffix :param outputImageFile: output image file filename :return: input image file filename: output resized image to outputImageFile input image binary bytes: resized image binary bytes \"\"\" openableImage = None if isinstance(inputImage, str): openableImage = inputImage elif isFileObject(inputImage): openableImage = inputImage elif isinstance(inputImage, bytes): inputImageLen = len(inputImage) openableImage = io.BytesIO(inputImage) imageFile = Image.open(openableImage) # imageFile.thumbnail(newSize, resample) if outputImageFile: # save to file imageFile.save(outputImageFile) imageFile.close() else: # save and return binary byte imageOutput = io.BytesIO() # imageFile.save(imageOutput) outputImageFormat = None if outputFormat: outputImageFormat = outputFormat elif imageFile.format: outputImageFormat = imageFile.format imageFile.save(imageOutput, outputImageFormat) imageFile.close() compressedImageBytes = imageOutput.getvalue() compressedImageLen = len(compressedImageBytes) compressRatio = float(compressedImageLen)/float(inputImageLen) print(\"%s -> %s, resize ratio: %d%%\" % (inputImageLen, compressedImageLen, int(compressRatio * 100))) return compressedImageBytes 调用： import sys import os curFolder = os.path.abspath(__file__) parentFolder = os.path.dirname(curFolder) parentParentFolder = os.path.dirname(parentFolder) parentParentParentFolder = os.path.dirname(parentParentFolder) sys.path.append(curFolder) sys.path.append(parentFolder) sys.path.append(parentParentFolder) sys.path.append(parentParentParentFolder) import datetime from crifanMultimedia import resizeImage def testFilename(): imageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day.png\" outputImageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day_300x300.png\" print(\"imageFilename=%s\" % imageFilename) beforeTime = datetime.datetime.now() resizeImage(imageFilename, (300, 300), outputImageFile=outputImageFilename) afterTime = datetime.datetime.now() print(\"procesTime: %s\" % (afterTime - beforeTime)) outputImageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day_800x800.png\" beforeTime = datetime.datetime.now() resizeImage(imageFilename, (800, 800), outputImageFile=outputImageFilename) afterTime = datetime.datetime.now() print(\"procesTime: %s\" % (afterTime - beforeTime)) def testFileObject(): imageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day.png\" imageFileObj = open(imageFilename, \"rb\") outputImageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day_600x600.png\" beforeTime = datetime.datetime.now() resizeImage(imageFileObj, (600, 600), outputImageFile=outputImageFilename) afterTime = datetime.datetime.now() print(\"procesTime: %s\" % (afterTime - beforeTime)) def testBinaryBytes(): imageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/take tomato.png\" imageFileObj = open(imageFilename, \"rb\") imageBytes = imageFileObj.read() # return binary bytes beforeTime = datetime.datetime.now() resizedImageBytes = resizeImage(imageBytes, (800, 800)) afterTime = datetime.datetime.now() print(\"procesTime: %s\" % (afterTime - beforeTime)) print(\"len(resizedImageBytes)=%s\" % len(resizedImageBytes)) # save to file outputImageFilename = \"/Users/crifan/dev/tmp/python/resize_image_demo/hot day_750x750.png\" beforeTime = datetime.datetime.now() resizeImage(imageBytes, (750, 750), outputImageFile=outputImageFilename) afterTime = datetime.datetime.now() print(\"procesTime: %s\" % (afterTime - beforeTime)) imageFileObj.close() def demoResizeImage(): testFilename() testFileObject() testBinaryBytes() if __name__ == \"__main__\": demoResizeImage() # imageFilename=/Users/crifan/dev/tmp/python/resize_image_demo/hot day.png # procesTime: 0:00:00.619377 # procesTime: 0:00:00.745228 # procesTime: 0:00:00.606060 # 1146667 -> 753258, resize ratio: 65% # procesTime: 0:00:00.773289 # len(resizedImageBytes)=753258 # procesTime: 0:00:00.738237 给图片画元素所属区域的边框，且带自动保存加了框后的图片 from PIL import Image from PIL import ImageDraw def imageDrawRectangle(inputImgOrImgPath, rectLocation, outlineColor=\"green\", outlineWidth=0, isShow=False, isAutoSave=True, saveTail=\"_drawRect_%wx%h\", isDrawClickedPosCircle=True, clickedPos=None, ): \"\"\"Draw a rectangle for image (and a small circle), and show it, Args: inputImgOrImgPath (Image/str): a pillow(PIL) Image instance or image file path rectLocation (tuple/list/Rect): the rectangle location, (x, y, width, height) outlineColor (str): Color name outlineWidth (int): rectangle outline width isShow (bool): True to call image.show() for debug isAutoSave (bool): True to auto save the image file with drawed rectangle saveTail(str): save filename tail part. support format %x/%y/%w/%h use only when isAutoSave=True clickedPos (tuple): x,y of clicked postion; default None; if None, use the center point isDrawClickedPosCircle (bool): draw small circle in clicked point Returns: modified image Raises: \"\"\" inputImg = inputImgOrImgPath if isinstance(inputImgOrImgPath, str): inputImg = Image.open(inputImgOrImgPath) draw = ImageDraw.Draw(inputImg) isRectObj = False hasX = hasattr(rectLocation, \"x\") hasY = hasattr(rectLocation, \"y\") hasWidth = hasattr(rectLocation, \"width\") hasHeight = hasattr(rectLocation, \"height\") isRectObj = hasX and hasY and hasWidth and hasHeight if isinstance(rectLocation, tuple): x, y, w, h = rectLocation if isinstance(rectLocation, list): x = rectLocation[0] y = rectLocation[1] w = rectLocation[2] h = rectLocation[3] elif isRectObj: x = rectLocation.x y = rectLocation.y w = rectLocation.width h = rectLocation.height w = int(w) h = int(h) x0 = x y0 = y x1 = x0 + w y1 = y0 + h draw.rectangle( [x0, y0, x1, y1], # fill=\"yellow\", # outline=\"yellow\", outline=outlineColor, width=outlineWidth, ) if isDrawClickedPosCircle: # radius = 3 # radius = 2 radius = 4 # circleOutline = \"yellow\" circleOutline = \"red\" circleLineWidthInt = 1 # circleLineWidthInt = 3 if clickedPos: clickedX, clickedY = clickedPos else: clickedX = x + w/2 clickedY = y + h/2 startPointInt = (int(clickedX - radius), int(clickedY - radius)) endPointInt = (int(clickedX + radius), int(clickedY + radius)) draw.ellipse([startPointInt, endPointInt], outline=circleOutline, width=circleLineWidthInt) if isShow: inputImg.show() if isAutoSave: saveTail = saveTail.replace(\"%x\", str(x)) saveTail = saveTail.replace(\"%y\", str(y)) saveTail = saveTail.replace(\"%w\", str(w)) saveTail = saveTail.replace(\"%h\", str(h)) inputImgPath = None if isinstance(inputImgOrImgPath, str): inputImgPath = str(inputImgOrImgPath) elif inputImg.filename: inputImgPath = str(inputImg.filename) if inputImgPath: imgFolderAndName, pointSuffix = os.path.splitext(inputImgPath) imgFolderAndName = imgFolderAndName + saveTail newImgPath = imgFolderAndName + pointSuffix newImgPath = findNextNumberFilename(newImgPath) else: curDatetimeStr = getCurDatetimeStr() # '20191219_143400' suffix = str(inputImg.format).lower() # 'jpeg' newImgFilename = \"%s%s.%s\" % (curDatetimeStr, saveTail, suffix) imgPathRoot = os.getcwd() newImgPath = os.path.join(imgPathRoot, newImgFilename) inputImg.save(newImgPath) return inputImg 说明： 相关函数，详见：findNextNumberFilename，或者干脆去掉这个逻辑即可。 调用： curBoundList = self.get_ElementBounds(eachElement) curWidth = curBoundList[2] - curBoundList[0] curHeight = curBoundList[3] - curBoundList[1] curRect = [curBoundList[0], curBoundList[1], curWidth, curHeight] curImg = CommonUtils.imageDrawRectangle(curImg, curRect, isShow=True, saveTail=\"_rect_%x|%y|%w|%h\", isDrawClickedPosCircle=False) 或： curTimeStr = CommonUtils.getCurDatetimeStr(\"%H%M%S\") curSaveTal = \"_rect_{}_%x|%y|%w|%h\".format(curTimeStr) curImg = CommonUtils.imageDrawRectangle(imgPath, curRect, isShow=True, saveTail=curSaveTal, isDrawClickedPosCircle=False) 效果： （1）给原图加上单个元素所属边框 （2）多次循环后，给同一张图中多个元素加上边框后 其他调用： imageDrawRectangle(curPillowImg, curLocation) imageDrawRectangle(curPillowImg, calculatedLocation) curImg = imageDrawRectangle(imgPath, firstMatchLocation, clickedPos=clickedPos) curImg = imageDrawRectangle(imgPath, firstMatchLocation) crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 20:23:40 "},"common_code/pillow.html":{"url":"common_code/pillow.html","title":"Pillow","keywords":"","body":"Pillow Python中图像处理用的最多是：Pillow Pillow 继承自：PIL PIL = Python Imaging Library 官网资料： Image Module — Pillow (PIL Fork) 7.0.0 documentation Image Module — Pillow (PIL Fork) 3.1.2 documentation 从二进制生成Image if isinstance(inputImage, bytes): openableImage = io.BytesIO(inputImage) curPillowImage = Image.open(openableImage) pillow变量是： # # 详见： 【已解决】Python如何从二进制数据中生成Pillow的Image 【已解决】Python的Pillow如何从二进制数据中读取图像数据 从Pillow的Image获取二进制数据 import io imageIO = io.BytesIO() curImg.save(imageIO, curImg.format) imgBytes = imageIO.getvalue() 详见： 【已解决】Python的Pillow如何返回图像的二进制数据 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 11:36:10 "},"common_code/audio.html":{"url":"common_code/audio.html","title":"音频","keywords":"","body":"音频 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanMultimedia.py https://github.com/crifan/crifanLibPython/blob/master/crifanLib/demo/crifanMultimediaDemo.py 播放音频 树莓派中用python播放音频 前提： 树莓派中，先去安装vlc： sudo apt-get install vlc 代码： import vlc instance = vlc.Instance('--aout=alsa') p = instance.media_player_new() m = instance.media_new('/home/pi/Music/lizhongsheng_massif_live.mp3') p.set_media(m) p.play() 即可播放音频。 实现设置音量，暂停，继续播放等操作的代码是： p.pause() vlc.libvlc_audio_set_volume(p, 40) p.play() vlc.libvlc_audio_set_volume(p, 90) Mac中调用mpv播放音频 播放音频： cmdPlayer = \"mpv\" cmdParaFilePath = tmpAudioFileFullPath cmdArgList = [cmdPlayer, cmdParaFilePath] if gCurSubProcess: gCurSubProcess.terminate() gCurSubProcess = subprocess.Popen(cmdArgList) log.debug(\"gCurSubProcess=%s\", gCurSubProcess) 停止播放： if audioControl == \"stop\": if gCurSubProcess: gCurSubProcess.terminate() respData = { audioControl: \"ok\" } else: respData = { audioControl: \"Unsupport command\" } 获取播放效果： if gCurSubProcess: isTerminated = gCurSubProcess.poll() # None # stdout_data, stderr_data = gCurSubProcess.communicate() # stdoutStr = str(stdout_data) # stderrStr = str(stderr_data) respData = { \"isTerminated\": isTerminated, # \"stdout_data\": stdoutStr, # \"stderr_data\": stderrStr, } 返回结果： 正在播放：返回isTerminated为null 被终止后，返回isTerminated为4 播放的效果： mac系统中播放音频 PyCharm的console中输出当前播放的信息 -》 如果是mac的terminal中，则是覆盖式的，不会这么多行 同时弹框GUI窗口 mp3 解析mp3等音频文件得到时长信息 用库： audioread GitHub beetbox/audioread: cross-library (GStreamer + Core Audio + MAD + FFmpeg) audio decoding for Python import audioread try: audioFullFilePath = \"/your/input/audio/file.mp3\" with audioread.audio_open(audioFullFilePath) as audioFp: audioInfo[\"duration\"] = audioFp.duration audioInfo[\"channels\"] = audioFp.channels audioInfo[\"sampleRate\"] = audioFp.samplerate except OSError as osErr: logging.error(\"OSError when open %s error %s\", audioFullFilePath, osErr) except EOFError as eofErr: logging.error(\"EOFError when open %s error %s\", audioFullFilePath, eofErr) except audioread.DecodeError as decodeErr: logging.error(\"Decode audio %s error %s\", audioFullFilePath, decodeErr) 后经整理成函数： import audioread def detectAudioMetaInfo(audioFullPath): \"\"\" detect audio meta info: duration, channels, sampleRate \"\"\" isOk = False errMsg = \"\" audioMetaInfo = { \"duration\": 0, \"channels\": 0, \"sampleRate\": 0, } try: with audioread.audio_open(audioFullPath) as audioFp: audioMetaInfo[\"duration\"] = audioFp.duration audioMetaInfo[\"channels\"] = audioFp.channels audioMetaInfo[\"sampleRate\"] = audioFp.samplerate isOk = True except OSError as osErr: errMsg = \"detect audio info error: %s\" % str(osErr) except EOFError as eofErr: errMsg = \"detect audio info error: %s\" % str(eofErr) except audioread.DecodeError as decodeErr: errMsg = \"detect audio info error: %s\" % str(decodeErr) if isOk: return isOk, audioMetaInfo else: return isOk, errMsg 调用： def demoDetectAudioMeta(): curPath = os.path.dirname(__file__) inputAudioList = [ \"input/audio/actual_aac_but_suffix_mp3.mp3\", \"input/audio/real_mp3_format.mp3\", \"not_exist_audio.wav\", \"input/audio/fake_audio_actual_image.wav\", ] for eachAudioPath in inputAudioList: eachAudioFullPath = os.path.join(curPath, eachAudioPath) isOk, errOrInfo = detectAudioMetaInfo(eachAudioFullPath) print(\"isOk=%s, errOrInfo=%s\" % (isOk, errOrInfo)) if __name__ == \"__main__\": demoDetectAudioMeta() 对应的音频文件，用MediaInfo检测出的信息： 正常mp3 异常mp3： 故意把png图片改成mp3 输出： # isOk=True, errOrInfo={'duration': 637.8, 'channels': 2, 'sampleRate': 44100} # isOk=True, errOrInfo={'duration': 2.3510204081632655, 'channels': 2, 'sampleRate': 44100} # isOk=False, errOrInfo=detect audio info error: [Errno 2] No such file or directory: '/Users/crifan/dev/dev_root/crifan/crifanLibPython/crifanLib/demo/not_exist_audio.wav' # isOk=False, errOrInfo=detect audio info error: crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 12:34:36 "},"common_code/video.html":{"url":"common_code/video.html","title":"视频","keywords":"","body":"视频 从视频中提取出音频mp3文件 import os import logging import subprocess videoFullpath = \"show_157712932_video.mp4\" startTimeStr = \"00:00:11.270\" # startTimeStr = \"%02d:%02d:%02d.%03d\" % (startTime.hours, startTime.minutes, startTime.seconds, startTime.milliseconds) endTimeStr = \"00:00:14.550\" # endTimeStr = \"%02d:%02d:%02d.%03d\" % (endTime.hours, endTime.minutes, endTime.seconds, endTime.milliseconds) outputAudioFullpath = \"show_157712932_audio_000011270_000014550.mp3\" # extract audio segment from video # ffmpeg -i show_157712932_video.mp4 -ss 00:00:11.270 -to 00:00:14.550 -b:a 128k show_157712932_audio_000011270_000014550.mp3 if not os.path.exists(outputAudioFullpath): ffmpegCmd = \"ffmpeg -i %s -ss %s -to %s -b:a 128k %s\" % (videoFullpath, startTimeStr, endTimeStr, outputAudioFullpath) subprocess.call(ffmpegCmd, shell=True) logging.info(\"Complete use ffmpeg extract audio: %s\", ffmpegCmd) 可以从mp4中提取出mp3音频： crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 12:00:50 "},"common_code/network.html":{"url":"common_code/network.html","title":"网络","keywords":"","body":"网络 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:58:18 "},"common_code/requests.html":{"url":"common_code/requests.html","title":"requests","keywords":"","body":"requests 下载图片，保存为二进制文件 import requests resp = requests.get(pictureUrl) with open(saveFullPath, 'wb') as saveFp: saveFp.write(resp.content) 详见： 【已解决】Python的requests中如何下载二进制数据保存为图片文件 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:59:07 "},"common_code/math.html":{"url":"common_code/math.html","title":"数学","keywords":"","body":"数学 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanMath.py md5 md5计算 md5 Python 3中已改名hashlib 且update参数只允许bytes 不允许str 的md5代码： from hashlib import md5 # only for python 3.x def generateMd5(strToMd5) : \"\"\" generate md5 string from input string eg: xxxxxxxx -> af0230c7fcc75b34cbb268b9bf64da79 :param strToMd5: input string :return: md5 string of 32 chars \"\"\" encrptedMd5 = \"\" md5Instance = md5() # print(\"type(md5Instance)=%s\" % type(md5Instance)) # type(md5Instance)= # print(\"type(strToMd5)=%s\" % type(strToMd5)) # type(strToMd5)= bytesToMd5 = bytes(strToMd5, \"UTF-8\") # print(\"type(bytesToMd5)=%s\" % type(bytesToMd5)) # type(bytesToMd5)= md5Instance.update(bytesToMd5) encrptedMd5 = md5Instance.hexdigest() # print(\"type(encrptedMd5)=%s\" % type(encrptedMd5)) # type(encrptedMd5)= # print(\"encrptedMd5=%s\" % encrptedMd5) # encrptedMd5=3a821616bec2e86e3e232d0c7f392cf5 return encrptedMd5 之前旧版本的Python 2（）版本： md5还是个独立模块 还没有并入hashlib 注： 好像python 2.7中已将md5并入hashlib 但是update参数还允许str（而不是bytes） update参数允许str 的md5代码： try: import md5 except ImportError: from hashlib import md5 def generateMd5(strToMd5) : encrptedMd5 = \"\" md5Instance = md5.new() #md5Instance= md5Instance.update(strToMd5) encrptedMd5 = md5Instance.hexdigest() #encrptedMd5=af0230c7fcc75b34cbb268b9bf64da79 return encrptedMd5 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:22:06 "},"common_syntax/":{"url":"common_syntax/","title":"常见语法","keywords":"","body":"常见语法 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:41:52 "},"common_syntax/function_parameter.html":{"url":"common_syntax/function_parameter.html","title":"函数参数","keywords":"","body":"函数参数 可变参数 之前一个用到了可变参数的函数是： def multipleRetry(self, functionInfoDict, maxRetryNum=5, sleepInterval=0.1): \"\"\" do something, retry mutiple time if fail Args: functionInfoDict (dict): function info dict contain functionCallback and [optional] functionParaDict maxRetryNum (int): max retry number sleepInterval (float): sleep time of each interval when fail Returns: bool Raises: \"\"\" doSuccess = False functionCallback = functionInfoDict[\"functionCallback\"] functionParaDict = functionInfoDict.get(\"functionParaDict\", None) curRetryNum = maxRetryNum while curRetryNum > 0: if functionParaDict: doSuccess = functionCallback(**functionParaDict) else: doSuccess = functionCallback() if doSuccess: break time.sleep(sleepInterval) curRetryNum -= 1 if not doSuccess: functionName = str(functionCallback) # '>' logging.error(\"Still fail after %d retry for %s\", functionName) return doSuccess 其中的： functionCallback(**functionParaDict) 中的： **functionParaDict 表示，dict类型的参数，内部包含多个key和value，用**去展开后，传入真正要执行的函数 几种调用中带参数的例子是： searchInputQuery = {\"type\":\"XCUIElementTypeSearchField\", \"name\":\"App Store\"} isInputOk = self.multipleRetry( { \"functionCallback\": self.wait_element_setText, \"functionParaDict\": { \"locator\": searchInputQuery, \"text\": appName, } } ) 之前原始写法： searchInputQuery = {\"type\":\"XCUIElementTypeSearchField\", \"name\":\"App Store\"} isInputOk = self.wait_element_setText(searchInputQuery, appName) 其中wait_element_setText的定义是： def wait_element_setText(self, locator, text): 对应着之前传入时的： \"functionParaDict\": { \"locator\": searchInputQuery, \"text\": appName, } 即可，给出上述细节，便于理解，传入的参数是如何用**展开的。 详见： 【已解决】Python中如何实现函数调用时多个可变数量的参数传递 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-26 11:44:46 "},"common_syntax/dict.html":{"url":"common_syntax/dict.html","title":"dict字典","keywords":"","body":"dict字典 删除dict中某个键（和值） 常见写法： del yourDict[\"keyToDelete\"] 更加Pythonic的写法： yourDict.pop(\"keyToDelete\") 注意： 为了防止出现KeyError，注意确保要删除的key都是存在的，否则就要先判断存在，再去删除。 合并2个dict的值 （1）如果无需保留原有（第一个dict）的值，则用update即可： firstDict.update(secondDict) 支持：Python >=3.5 （2）如果要保留之前的dict的值，则用**展开 thirdDict = (**firstDict, **secondDict) 支持：Python 2和 Python 详见： 【已解决】Python中如何合并2个dict字典变量的值 有序字典OrderedDict的初始化 from collections import OrderedDict orderedDict = OrderedDict() 后续正常作为普通dict使用 >>> from collections import OrderedDict >>> orderedDict = OrderedDict() >>> orderedDict[\"key2\"] = \"value2\" >>> orderedDict[\"key1\"] = \"value1\" >>> orderedDict[\"key3\"] = \"value3\" >>> orderedDict OrderedDict([('key2', 'value2'), ('key1', 'value1'), ('key3', 'value3')]) dict的递归的合并更新 def recursiveMergeDict(aDict, bDict): \"\"\" Recursively merge dict a to b, return merged dict b Note: Sub dict and sub list's won't be overwritten but also updated/merged example: (1) input and output example: input: { \"keyStr\": \"strValueA\", \"keyInt\": 1, \"keyBool\": true, \"keyList\": [ { \"index0Item1\": \"index0Item1\", \"index0Item2\": \"index0Item2\" }, { \"index1Item1\": \"index1Item1\" }, { \"index2Item1\": \"index2Item1\" } ] } and { \"keyStr\": \"strValueB\", \"keyInt\": 2, \"keyList\": [ { \"index0Item1\": \"index0Item1_b\" }, { \"index1Item1\": \"index1Item1_b\" } ] } output: { \"keyStr\": \"strValueB\", \"keyBool\": true, \"keyInt\": 2, \"keyList\": [ { \"index0Item1\": \"index0Item1_b\", \"index0Item2\": \"index0Item2\" }, { \"index1Item1\": \"index1Item1_b\" }, { \"index2Item1\": \"index2Item1\" } ] } (2) code usage example: import copy cDict = recursiveMergeDict(aDict, copy.deepcopy(bDict)) Note: bDict should use deepcopy, otherwise will be altered after call this function !!! \"\"\" aDictItems = None if (sys.version_info[0] == 2): # is python 2 aDictItems = aDict.iteritems() else: # is python 3 aDictItems = aDict.items() for aKey, aValue in aDictItems: # print(\"------ [%s]=%s\" % (aKey, aValue)) if aKey not in bDict: bDict[aKey] = aValue else: bValue = bDict[aKey] # print(\"aValue=%s\" % aValue) # print(\"bValue=%s\" % bValue) if isinstance(aValue, dict): recursiveMergeDict(aValue, bValue) elif isinstance(aValue, list): aValueListLen = len(aValue) bValueListLen = len(bValue) bValueListMaxIdx = bValueListLen - 1 for aListIdx in range(aValueListLen): # print(\"---[%d]\" % aListIdx) aListItem = aValue[aListIdx] # print(\"aListItem=%s\" % aListItem) if aListIdx 调用举例： templateJson = { \"author\": \"Crifan Li \", \"description\": \"gitbook书的描述\", \"gitbook\": \"3.2.3\", \"language\": \"zh-hans\", \"links\": { \"sidebar\": { \"主页\": \"http://www.crifan.com\" } }, \"plugins\": [ \"theme-comscore\", \"anchors\", \"-lunr\", \"-search\", \"search-plus\", \"disqus\", \"-highlight\", \"prism\", \"prism-themes\", \"github-buttons\", \"splitter\", \"-sharing\", \"sharing-plus\", \"tbfed-pagefooter\", \"expandable-chapters-small\", \"ga\", \"donate\", \"sitemap-general\", \"copy-code-button\", \"callouts\", \"toolbar-button\" ], \"pluginsConfig\": { \"callouts\": { \"showTypeInHeader\": false }, \"disqus\": { \"shortName\": \"crifan\" }, \"donate\": { \"alipay\": \"https://www.crifan.com/files/res/crifan_com/crifan_alipay_pay.jpg\", \"alipayText\": \"支付宝打赏给Crifan\", \"button\": \"打赏\", \"title\": \"\", \"wechat\": \"https://www.crifan.com/files/res/crifan_com/crifan_wechat_pay.jpg\", \"wechatText\": \"微信打赏给Crifan\" }, \"ga\": { \"token\": \"UA-28297199-1\" }, \"github-buttons\": { \"buttons\": [ { \"count\": true, \"repo\": \"gitbook_name\", \"size\": \"small\", \"type\": \"star\", \"user\": \"crifan\" }, { \"count\": false, \"size\": \"small\", \"type\": \"follow\", \"user\": \"crifan\", \"width\": \"120\" } ] }, \"prism\": { \"css\": [\"prism-themes/themes/prism-atom-dark.css\"] }, \"sharing\": { \"all\": [ \"douban\", \"facebook\", \"google\", \"instapaper\", \"line\", \"linkedin\", \"messenger\", \"pocket\", \"qq\", \"qzone\", \"stumbleupon\", \"twitter\", \"viber\", \"vk\", \"weibo\", \"whatsapp\" ], \"douban\": false, \"facebook\": true, \"google\": false, \"hatenaBookmark\": false, \"instapaper\": false, \"line\": false, \"linkedin\": false, \"messenger\": false, \"pocket\": false, \"qq\": true, \"qzone\": false, \"stumbleupon\": false, \"twitter\": true, \"viber\": false, \"vk\": false, \"weibo\": true, \"whatsapp\": false }, \"sitemap-general\": { \"prefix\": \"https://book.crifan.com/gitbook/gitbook_name/website/\" }, \"tbfed-pagefooter\": { \"copyright\": \"crifan.com，使用署名4.0国际(CC \\\"BY 4.0)协议发布\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\", \"modify_label\": \"最后更新：\" }, \"theme-default\": { \"showLevel\": true }, \"toolbar-button\": { \"icon\": \"fa-file-pdf-o\", \"label\": \"下载PDF\", \"url\": \"http://book.crifan.com/books/gitbook_name/pdf/gitbook_name.pdf\" } }, \"root\": \"./src\", \"title\": \"Gitbook的书名\" } currentJson = { \"description\": \"crifan整理的Python各个方面常用的代码段，供需要的参考。\", \"pluginsConfig\": { \"github-buttons\": { \"buttons\": [{ \"repo\": \"python_common_code_snippet\" }] }, \"sitemap-general\": { \"prefix\": \"https://book.crifan.com/gitbook/python_common_code_snippet/website/\" }, \"toolbar-button\": { \"url\": \"http://book.crifan.com/books/python_common_code_snippet/pdf/python_common_code_snippet.pdf\" } }, \"title\": \"Python常用代码段\" } bookJson = recursiveMergeDict(templateJson, copy.deepcopy(currentJson)) crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:44:31 "},"common_syntax/list_set.html":{"url":"common_syntax/list_set.html","title":"list列表和set集合","keywords":"","body":"list列表和set集合 list vs set set 适用于检测某元素是否在集合内、对集合进行一定的数学操作 不支持indexing，slicing list 普通的数组 支持indexing，slicing 把list换成set someSet = set([]) for eachItem in someList: someSet.add(eachItem) set集合转换为字符串 someSetStr = \", \".join(someSet) crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:48:32 "},"common_syntax/sort.html":{"url":"common_syntax/sort.html","title":"sort排序","keywords":"","body":"sort排序 详见： https://github.com/crifan/crifanLibPython/blob/master/crifanLib/crifanDict.py https://github.com/crifan/crifanLibPython/blob/master/crifanLib/demo/crifanDictDemo.py 对字典根据key去排序 from collections import OrderedDict def sortDictByKey(originDict): \"\"\" Sort dict by key \"\"\" originItems = originDict.items() sortedOriginItems = sorted(originItems) sortedOrderedDict = OrderedDict(sortedOriginItems) return sortedOrderedDict 调用： def demoSortDictByKey(): originDict = { \"c\": \"abc\", \"a\": 1, \"b\": 22 } print(\"originDict=%s\" % originDict) # originDict={'c': 'abc', 'a': 1, 'b': 22} sortedOrderedDict = sortDictByKey(originDict) print(\"sortedOrderedDict=%s\" % sortedOrderedDict) # sortedOrderedDict=OrderedDict([('a', 1), ('b', 22), ('c', 'abc')]) sort和sorted # Function: Demo sorted # mainly refer official doc: # 排序指南 — Python 3.8.2 文档 # https://docs.python.org/zh-cn/3/howto/sorting.html # Author: Crifan Li # Update: 20200304 from operator import itemgetter, attrgetter print(\"%s %s %s\" % ('='*40, \"sort\", '='*40)) originIntList = [5, 2, 3, 1, 4] originIntList.sort() sortedSelfIntList = originIntList print(\"sortedSelfIntList=%s\" % sortedSelfIntList) # sortedSelfIntList=[1, 2, 3, 4, 5] print(\"%s %s %s\" % ('='*40, \"sorted\", '='*40)) intList = [5, 2, 3, 1, 4] sortedIntList = sorted(intList) print(\"sortedIntList=%s\" % sortedIntList) # sortedIntList=[1, 2, 3, 4, 5] reversedSortIntList = sorted(intList, reverse=True) print(\"reversedSortIntList=%s\" % reversedSortIntList) # reversedSortIntList=[5, 4, 3, 2, 1] intStrDict = {5: 'A', 1: 'D', 2: 'B', 4: 'E', 3: 'B'} dictSortedIntList = sorted(intStrDict) print(\"dictSortedIntList=%s\" % dictSortedIntList) # dictSortedIntList=[1, 2, 3, 4, 5] normalStr = \"Crifan Li best love language is Python\" strList = normalStr.split() print(\"strList=%s\" % strList) sortedStrList = sorted(strList, key=str.lower) print(\"sortedStrList=%s\" % sortedStrList) # strList=['Crifan', 'Li', 'best', 'love', 'language', 'is', 'Python'] # sortedStrList=['best', 'Crifan', 'is', 'language', 'Li', 'love', 'Python'] studentTupleList = [ # name, grade, age ('Cindy', 'A', 15), ('Crifan', 'B', 12), ('Tony', 'B', 10), ] sortedTupleList_lambda = sorted(studentTupleList, key=lambda student: student[2]) # [2] is age print(\"sortedTupleList_lambda=%s\" % sortedTupleList_lambda) # sortedTupleList_lambda=[('Tony', 'B', 10), ('Crifan', 'B', 12), ('Cindy', 'A', 15)] # same as single function: def getStudentAge(curStudentTuple): return curStudentTuple[2] # [2] is age sortedTupleList_singleFunction = sorted(studentTupleList, key=getStudentAge) print(\"sortedTupleList_singleFunction=%s\" % sortedTupleList_singleFunction) # sortedTupleList_singleFunction=[('Tony', 'B', 10), ('Crifan', 'B', 12), ('Cindy', 'A', 15)] # same as operator itemgetter: sortedTupleList_operator = sorted(studentTupleList, key=itemgetter(2)) print(\"sortedTupleList_operator=%s\" % sortedTupleList_operator) # sortedTupleList_operator=[('Tony', 'B', 10), ('Crifan', 'B', 12), ('Cindy', 'A', 15)] class Student: def __init__(self, name, grade, age): self.name = name self.grade = grade self.age = age def __repr__(self): return repr((self.name, self.grade, self.age)) studentObjectList = [ Student('john', 'A', 15), Student('jane', 'A', 15), Student('dave', 'A', 15), ] sortedObjectList = sorted(studentObjectList, key=lambda student: student.age) print(\"sortedObjectList=%s\" % sortedObjectList) # sortedObjectList=[('john', 'A', 15), ('jane', 'A', 15), ('dave', 'A', 15)] # same as operator attrgetter: sortedObjectList_operator = sorted(sortedObjectList, key=attrgetter('age')) print(\"sortedObjectList_operator=%s\" % sortedObjectList_operator) # sortedObjectList_operator=[('john', 'A', 15), ('jane', 'A', 15), ('dave', 'A', 15)] crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 13:17:24 "},"common_syntax/enum.html":{"url":"common_syntax/enum.html","title":"enum枚举","keywords":"","body":"enum枚举 枚举基本用法 枚举定义 举例1： from enum import Enum class BatteryState(Enum): Unknown = 0 Unplugged = 1 Charging = 2 Full = 3 举例2： import enum class ScreenshotQuality(enum.Enum): Original = 0 Medium = 1 Low = 2 举例3： class SentenceInvalidReason(Enum): NONE = \"none\" UNKNOWN = \"unknown\" EMPTY = \"empty TOO_SHORT = \"too short\" TOO_LONG = \"too long\" TOO_MANY_INVALID_WORD = \"contain too many invalid words\" 初始化创建枚举值 直接传入对应的（此处是int）值即可： batteryStateInt = 2 curBattryStateEnum = BatteryState(batteryStateInt) log输出是： curBattryStateEnum=BatteryState.Charging 获取枚举的名称 curBattryStateName = curBattryStateEnum.name 输出：'Charging' 获取枚举的值 curBattryStateValue = curBattryStateEnum.value 输出：2 类似，直接从定义中获取值： gScreenQuality = ScreenshotQuality.Low.value # 2 枚举高级用法 给枚举中添加函数 class TipType(enum.Enum): NoTip = \"NoTip\" TenPercent = \"TenPercent\" FifthPercent = \"FifthPercent\" TwentyPercent = \"TwentyPercent\" # @property def getTipPercent(self): tipPercent = 0.0 if self == TipType.NoTip: tipPercent = 0.0 elif self == TipType.TenPercent: tipPercent = 0.10 elif self == TipType.FifthPercent: tipPercent = 0.15 elif self == TipType.TwentyPercent: tipPercent = 0.20 gLog.debug(\"self=%s -> tipPercent=%s\", self, tipPercent) return tipPercent 调用： tipPercent = initiatorTipType.getTipPercent() # tipPercent=0.1 注意事项 字符串枚举定义最后不要加逗号 enum定义期间不要加（多余的）逗号： class ScreenshotQuality(enum.Enum): Original = 0, Medium = 1, Low = 2, 否则value就是tuple元祖了： gScreenQuality = ScreenshotQuality.Low.value # 实际上是 (2,) print(\"gScreenQuality=%s\" % gScreenQuality) # gScreenQuality=2 print(\"type(gScreenQuality)=%s\" % type(gScreenQuality)) # type(gScreenQuality)= crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 12:56:53 "},"common_syntax/collections.html":{"url":"common_syntax/collections.html","title":"collections集合","keywords":"","body":"collections集合 根据官网： collections --- 容器数据类型 — Python 3.8.1 文档 介绍，集合有很多种，列出供了解： namedtuple()：创建命名元组子类的工厂函数 deque：类似列表(list)的容器，实现了在两端快速添加(append)和弹出(pop) ChainMap：类似字典(dict)的容器类，将多个映射集合到一个视图里面 Counter：字典的子类，提供了可哈希对象的计数功能 OrderedDict：字典的子类，保存了他们被添加的顺序 defaultdict：字典的子类，提供了一个工厂函数，为字典查询提供一个默认值 UserDict：封装了字典对象，简化了字典子类化 UserList：封装了列表对象，简化了列表子类化 UserString：封装了列表对象，简化了字符串子类化 待以后用到了，再详细总结。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 13:07:42 "},"appendix/":{"url":"appendix/","title":"附录","keywords":"","body":"附录 下面列出相关参考资料。 crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-03-17 09:11:34 "},"appendix/reference.html":{"url":"appendix/reference.html","title":"参考资料","keywords":"","body":"参考资料 【已解决】AppStore自动安装iOS的app：逻辑优化加等待和多试几次 【已解决】Python中如何实现函数调用时多个可变数量的参数传递 【已解决】Python中如何合并2个dict字典变量的值 【已解决】Python中给Mac中文件加上可执行权限 【已解决】Python如何从二进制数据中生成Pillow的Image 【已解决】Python的Pillow如何从二进制数据中读取图像数据 【已解决】Python的requests中如何下载二进制数据保存为图片文件 【已解决】Python中用Pillow去缩小分辨率以及保持画质同时最大程度压缩图片 【已解决】Python中实现二进制数据的图片的压缩 【已解决】Python中如何解析mp3等音频文件得到时长信息 【已解决】用Python代码从视频中提取出音频mp3文件 【已解决】Python 3中通过二进制生成文件类型对象 【已解决】用ffmpeg从mp4视频中提取出整个mp3以及根据时间段去分割mp3 【已解决】python中从文件名后缀推断出MIME类型 【已解决】Python中从int值生成Enum枚举和获取枚举值的字符串或名字 【未解决】python的wda中调整appium的settings参数实现功能优化 【已解决】Python中实现类似touch创建一个空文件 【已解决】Python中根据key去对字典排序 【已解决】Python 3中如何把字符串str转换成字节码bytes 【已解决】Python的md5运行出错：发生异常AttributeError builtin_function_or_method object has no attribute new 【已解决】Python 3中md5报错：Unicode-objects must be encoded before hashing 【已解决】Python 3中判断变量类型 【已解决】Python中删除字典dict中的键值 【已解决】python中判断单个或多个单词是否是全部小写或首字母小写 【已解决】Python中如何让Enum的字符串输出字段的值而不带类型的前缀 – 在路上 【已解决】Python中给枚举添加内置函数或属性 【基本解决】Python中把wma、wav等格式音频转换为mp3 – 在路上 【已解决】Python中如何格式化大小为人类易读的效果 【已解决】Python中获取带毫秒的时间戳 【已解决】Python中实现dict的递归的合并更新 【已解决】Python中把list换成set 【整理】python中一次性创建多级文件夹，判断一个文件夹是否已经存在 – 在路上 【已解决】Python中如何递归的删除整个非空文件夹 – 在路上 python - Correct way to write line to file? - Stack Overflow How do you do a simple \"chmod +x\" from within python? - Stack Overflow io.BytesIO.getvalue 排序指南 — Python 3.8.2 文档 Python 常用指引 — Python 3.8.2 文档 Built-in Functions — Python 3.8.2 documentation operator — Standard operators as functions — Python 3.8.2 documentation Python 常用指引 — Python 3.8.2 文档 3.8.2 Documentation 编程常见问题 — Python 3.8.2 文档 术语对照表 — Python 3.8.2 文档 enum — Support for enumerations — Python 3.8.2 documentation enum --- 对枚举的支持 — Python 3.9.0a4 文档 collections --- 容器数据类型 — Python 3.8.1 文档 md5 not support in python 3.6 and django 1.10 - Stack Overflow list - Python: how to join entries in a set into one string? - Stack Overflow crifan.com，使用署名4.0国际(CC BY 4.0)协议发布 all right reserved，powered by Gitbook最后更新： 2020-06-27 18:52:16 "}}